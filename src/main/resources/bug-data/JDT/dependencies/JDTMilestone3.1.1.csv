bug_id,Depends On,Title,target_milestone,assigned_to,bug_severity,priority,creation_ts,Fixed Date,Duration,churned_loc,description,,,,
100153,, [1.5][compiler] Bound check failure on recursive formal bound  ,3.1.1,philippe_mulet@fr.ibm.com,normal,P3,37056.31111,37076.40815,20.09703704,16,3.1rc2\n\nThe following program should be accepted:\n\npublic class X<T extends X<T>> {\n\tvoid foo(X<? extends T> x) {}\n},,,,
103528,, [1.5][compiler] compiler allows invalid assignment with method type parameter and nested wildcards  ,3.1.1,philippe_mulet@fr.ibm.com,normal,P3,37083.61597,37090.50581,6.889837963,290,"I20050627-1435 (3.1), maybe connected to / dup of bug 103485.\n\nEclipse accepts this:\n\nclass Hover {\n    <T extends Collection<? extends Number>> T getLonger(T t1, T t2) {\n        return t1.size() > t2.size() ? t1 : t2;\n    }\n    \n    void m(HashSet<?> list, ArrayList<?> set) {\n        getLonger(list, set);\n    }\n}\n\njavac 1.5.0_04: 1 error:\n<T>getLonger(T,T) in xy.Hover cannot be applied to\n(java.util.HashSet<capture of ?>,java.util.ArrayList<capture of ?>)",,,,
105531,, [1.5][compiler] ecj from CVS generates spurious incomprehensible error  ,3.1.1,philippe_mulet@fr.ibm.com,blocker,P3,37099.75069,37113.39059,13.63989583,190,"I have been compiled the generics branch of GNU Classpath with ecj for a while,\nsuccessfully.  However, after updating to the latest CVS version this week (most\nrecently, yesterday's (27/7/2005)), I get a strange error which makes the build\nfail:\n\n1445. ERROR in ../java/lang/ref/ReferenceQueue.java\n (at line 91)\n        ref.nextOnQueue = first == null ? ref : first;\n                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^\nType mismatch: cannot convert from Reference<capture-of ? extends T> to\nReference<capture-of ? extends T>\n\n(This is the only error; there are plenty of warnings at present due to the use\nof raw collections).\n\nTo me, the error doesn't even make sense, as the two are identical.  Finding a\nmachine with a copy of Sun's proprietary javac for 1.5 results in a successful\ncompile, as did previous versions of ecj.\n\nFWIW, ref is of type Reference<? extends T> and its nextOnQueue field is of type\nReference<T>.  first is of type Reference (although I still get the error with\nReference<T>).  I've tried casts and a variety of other things to make this\nwork, but to no avail.  As I say, this code hasn't changed and it does compile\nwith earlier versions and Sun's javac.  If there is a problem, the error message\ncould at least be more understandable.\n\nThanks.",,,,
104738,, [1.5][compiler] Enclosing method attribute is generated for member type of a local type  ,3.1.1,Olivier_Thomann@ca.ibm.com,normal,P3,37092.72986,37096.46531,3.735451389,12,"In case a member type is within a local class, it should not get an enclosing\nmethod attribute.\n\npublic class Test {\npublic static void main(String[] args) throws Exception  {\n\tclass MyLocal$A {\n\t\tclass Member {\n\t\t}\n\t};\n\tSystem.out.println(MyLocal$A.Member.class.getEnclosingMethod());\n\tSystem.out.println(MyLocal$A.Member.class.getEnclosingConstructor());\n}\n}\n\nAt runtime we get:\nException in thread ""main"" java.lang.InternalError: Enclosing method not found\n        at java.lang.Class.getEnclosingMethod(Class.java:916)\n        at X.main(X.java:7)\n\nWe should check for isNestedType() && !isMemberType() to find out if we should\nadd an enclosing method attribute instead of checking isAnonymous() ||\nisLocalType().",,,,
101387,, [1.5][compiler] Incorrect Cycle detected in type hierarchy error  ,3.1.1,kent_johnson@ca.ibm.com,normal,P3,37063.87847,37076.61544,12.73696759,76,"The compiler is incorrectly reporting a problem with parameterized classes when their parameters are \npopulated using nested classes more than one level deep. The code in question compiles & runs fine \nunder javac. Greatly simplified test case (which I think should compile):\n\nabstract class ObjectInput {}\n\nabstract class Factory<O, I extends ObjectInput, C extends I> {}\n\nclass Foo {}\n\npublic class FooFactory extends \n    Factory<Foo, FooFactory.Input, FooFactory.CreateInput> {\n\n  static class Input extends ObjectInput {}\n  \n  static class CreateInput extends Input {}\n}\n\nThere are then errors reported on the ""Input"" near the end, on the ""FooFactory.CreateInput"" in the \nFooFactory parameter population, and on ""FooFactory"" itself. \n\nI think the primal error is the one on ""Input"", which is: ""Cycle detected: a cycle exists in the type \nhierarchy between FooFactory.CreateInput and FooFactory""",,,,
103994,, [1.5][compiler] Internal compiler error while overriding bootstrap class  ,3.1.1,philippe_mulet@fr.ibm.com,major,P3,37086.39097,37090.36139,3.970416667,50,Creates a new java 5 project:\n\npackage java.nio.channels.spi,\n\npublic abstract class AbstractSelectableChannel\n\textends java.nio.channels.SelectableChannel\n{\n}\n\npackage test,\n\nclass A<C extends java.nio.channels.Channel>\n{\n\tclass B\n\t\textends A<java.nio.channels.SocketChannel>\n\t{\n\t}\n}\n\nThen an internal compiler error was issued:\njava.lang.NullPointerException\n\tat\norg.eclipse.jdt.internal.compiler.lookup.ReferenceBinding.implementsInterface(ReferenceBinding.java:682)\n\tat\norg.eclipse.jdt.internal.compiler.lookup.ReferenceBinding.isCompatibleWith(ReferenceBinding.java:768)\n\tat\norg.eclipse.jdt.internal.compiler.lookup.TypeVariableBinding.boundCheck(TypeVariableBinding.java:135)\n\tat\norg.eclipse.jdt.internal.compiler.lookup.ParameterizedTypeBinding.boundCheck(ParameterizedTypeBinding.java:58)\n\tat\norg.eclipse.jdt.internal.compiler.ast.ParameterizedSingleTypeReference.checkBounds(ParameterizedSingleTypeReference.java:40)\n\tat\norg.eclipse.jdt.internal.compiler.lookup.ClassScope.checkParameterizedTypeBounds(ClassScope.java:702)\n\tat\norg.eclipse.jdt.internal.compiler.lookup.ClassScope.connectTypeHierarchy(ClassScope.java:935)\n\tat\norg.eclipse.jdt.internal.compiler.lookup.ClassScope.connectMemberTypes(ClassScope.java:723)\n\tat\norg.eclipse.jdt.internal.compiler.lookup.ClassScope.connectTypeHierarchy(ClassScope.java:936)\n\tat\norg.eclipse.jdt.internal.compiler.lookup.CompilationUnitScope.connectTypeHierarchy(CompilationUnitScope.java:254)\n\tat\norg.eclipse.jdt.internal.compiler.lookup.LookupEnvironment.completeTypeBindings(LookupEnvironment.java:195)\n...\n\nThe null reference is SourceTypeBinding.superInterfaces for class\nAbstractSelectableChannel.\nNo error when the type parameter of class A is changed into <C extends\nSocketChannel>,,
101283,, [1.5][javadoc] Javadoc validation raises missing implementation in compiler  ,3.1.1,frederic_fusier@fr.ibm.com,normal,P3,37063.50903,37077.51225,14.00321759,727,"Build 3.1rc3\n\nThe following code causes compiler to reject it due to missing some support for it:\n\npackage foo;\n\npublic class ListenerSupport<T, F> {\n\n\t/**\n\t * @param <T>\n\t * @param <F>\n\t */\n\tclass Entry<L, R> {\n\t\t// empty\n\t}\n}",,,,
102650,, [ast rewrite] Removing all TYPE_PARAMETERS_PROPERTY values in a derived type gives incompilable code  ,3.1.1,martin_aeschlimann@ch.ibm.com,normal,P3,37075.41597,37083.4876,8.071631944,94,"(RC3)\n\nConsider a class:\npublic class B<T> extends A {}\n\nWe create an ASTRewrite and getListRewrite (lrw) for a node corresponding to \nthe type B and the TypeDeclaration.TYPE_PARAMETERS_PROPERTY. Then we remove all \nthe nodes from the list:\nList list = lrw.getOriginalList();\nfor (Iterator it = list.iterator(); it.hasNext(); ) {\n\tlrw.remove((ASTNode)it.next(), null);\n}\n\nand then we apply changes (rewrite the AST). The following code results:\npublic class Bextends A {}\n\nwhich is wrong. The only thing I found out is that rewriteAst() generates two \nconsecutive DeleteEdits of length two. Everything is OK if there is \nno ""extends"" clause.",,,,
100233,, [1.5] Incorrect overriding marker for bad overriding with generics  ,3.1.1,markus_keller@ch.ibm.com,normal,P3,37056.53056,37121.48669,64.95613426,744,"Hi.  The following code contains a bug in inheritance of generic methods:\n\nabstract class A<T> {\n  void g1 (T t) {\n    System.out.println(""g1 base: "" + t);\n  }\n  void g2 (T t) {\n    System.out.println(""g2 base: "" + t);\n  }\n}\n\npublic class B extends A<java.util.List<Number>> {\n  void g1 (java.util.List<?> t) {\n    System.out.println(""g1 derived: "" + t);\n  }\n  void g2 (java.util.List<Number> t) {\n    System.out.println(""g2 derived: "" + t);\n  }\n  public static void main (String[] args) {\n    B b = new B();\n    b.g1(new java.util.ArrayList<Number>());\n    b.g2(new java.util.ArrayList<Number>());\n  }\n}\n\nNotice that B.g1() does not override A.g1() because it declares a type parameter\nincompatible with the bound T->List<Number> established by class B.\n\nThe JDT compiler is working correctly; output is:\n\ng1 base: []\ng2 derived: []\n\nand in the bytecode, B has a stub for erasure delegation g2(Object)->g2(List)\nbut not for g1(Object)->g1(List).\n\nThe problem is in the editor.  There is a marker saying that B.g1() overrides\nA.g1(); it's wrong as there is no overriding in this case, only overloading.\nI performed some experiments with variations of this example, and it seems that\nthe source editor ignores completely the parameters' generic types to infer\ninheritance, even though it considers generic type info from class hierarchy:\nif I declare B.g2(String), the overriding marker disappears because String is\nnot compatible with B's T->List<Number>.\n\nIf I tag B's methods with the annotation @Override, the behavior is correct.\nThe annotation is OK for g2(), but at g1() the compiler flags an error:\n""The method g1(List<?>) of type B must override a superclass method"".\nThis shows that the compiler and the editor's code responsible for marker\ngeneration are not using the same strategy to validate method overriding.\n\nThis wrong marker is an usability problem, but a relatively severe one because\nit induces the programmer to error.  I just had this kind of error in my app\nand it was difficult to analyse because I failed to inherit a method, so the\nwrong method was being invoked, but inspection of the source didn't reveal the\nproblem because I blindly trusted the overriding marker -- shame on me for not\nusing the @Override tag, I know -- so I only caught this bug after laborious\nstep-by-step debugging.",,,,
105623,," [preferences] ""restore defaults"" has inconsistent behavior in project properties  ",3.1.1,martin_aeschlimann@ch.ibm.com,normal,P3,37100.83819,37105.29284,4.454641204,6,"On each of the JDT project property panes, ""restore defaults"" clears \nthe ""enable project specific settings"" checkbox, disables the rest of the \npreference fields, and sets their displayed (greyed) contents to default.  \nHowever, it evidently sets the displayed content to *factory* default.  \n\nThis is misleading, because if workspace preferences have been changed from \nfactory defaults, it is the workspace settings that will be in effect \nafter ""restore defaults"" in a project property pane.  It can also create a \nmisleading situation if the user checks the ""enable project specific settings"" \ncheckbox, because the fields will be re-enabled and will contain factory \ndefault rather than current workspace preferences.\n\nTo see this in action:\n\n1. Go to workspace preferences, Java / Compiler / Building.  Click ""restore \ndefaults"" to restore factory defaults.  Note that ""max number of problems"" is \n100, and ""enable use of exclusion patterns"" is checked.\n\n2. Change ""max number of problems"" to 50, and clear ""enable use of exclusion \npatterns.  Click OK.\n\n3. Create a new Java project (or edit an existing one with defaulted values).  \nView its project properties, Java / Compiler / Building.  Note that the values \ndisplayed are the workspace settings (50, unchecked).\n\n4. Click ""restore defaults"".  Note that the ""enable project specific settings"" \nis unchecked, and the displayed values of the settings change to 100 and \nchecked, that is, to the factory defaults.  (This happens regardless of whether \nthe project specific settings checkbox had been checked, and regardless of \nwhether the values had been changed.)  EXPECTED: values should be 50/unchecked, \nsame as workspace preferences.\n\n5. Click OK to dismiss the property pane; then launch it again.  Note that the \nvalues have (correctly) returned to the workspace values, 50/unchecked.  So \ndespite the misleading display, ""restore defaults"" actually led us to the \ncurrent workspace preferences.\n\n6. Click ""restore defaults""; note settings change back to 100/checked.  Now \ncheck ""enable project specific settings"".  Note settings are still 100/checked.\n\n7. Click OK to dismiss the property pane; then launch it again.  Note that \nsettings are 100/checked.  In this case, ""restore defaults"" led us to factory \ndefaults.\n\nSo depending on the precise set of operations, ""restore defaults"" has two \ndifferent meanings.  EXPECTED: ""restore defaults"", in a project properties \npane, should ALWAYS mean ""return to current workspace settings"".",,,,
103377,, [refactoring] PromoteTempToField doesn't properly set the type and the modifiers of the resulting variable declaration statement  ,3.1.1,markus_keller@ch.ibm.com,critical,P3,37082.65,37112.60758,29.95758102,60,"If you change the getType() of VariableDeclarationStatement class to return\ndouble instead of int, three tests are failing in\norg.eclipse.jdt.ui.tests.refactoring.PromoteTempToFieldTests.\nThey are test8, test13 and test15 (existing tests in 3.1).\nThree new tests are also failing.\ntestMultiVariableDeclFragment01, testMultiVariableDeclFragment02,\ntestMultiVariableDeclFragment03.\nThese tests are new since 3.1 is out.\n\nThe problem comes from the fact that the type of the variable declaration\nstatement is not set. So a default type (int) is retrieved. I will attach a\npatch for it.\nThis would be a candidate for 3.1.1.",,,,
105430,, ecj chokes when classpath has leading separator  ,3.1.1,Olivier_Thomann@ca.ibm.com,normal,P3,37099.28333,37159.56123,60.27789352,39,"The new classpath parser in ecj can't cope with classpaths with leading\nseparators.  I can't find any documentation as to whether this is valid or not,\nbut I've seen it used several times, and other Java compilers accept it.\n\nThe attached patch fixes.",,,,
105635,, incorrect parsing of field declarations with generic types  ,3.1.1,Olivier_Thomann@ca.ibm.com,major,P3,37101.54306,37110.46488,8.921828704,124,"A field declaration with a generic type and trailing brackets and multiple\nfragements does not parse correctly:\n\ne.g.: public java.util.List<Integer> i[],j,k;\nor    public java.util.List<Integer> i,j[];\n\n\nclass T { \npublic java.util.List<Integer> i,j[],k;\nvoid m() {\n  i[0] = null; // OK but should not be\n  j[0] = null;\n  k[0] = null; // OK but should not be\n}\n}\n\nThe parser considers the type common to all the fragments to be an array type.\nThis does not happen if the common type is a primitive type or a non-generic\nreference type.  It does happen no matter which fragment the brackets are on.\nOne can see the error by looking at the resulting AST as well, though \ninterestingly, the AST appears correct for the case above, but is clearly wrong\nfor the case where the brackets are on j.  \n\nI would try to debug this further, but the parser is table driven and I do not\nknow where the files that create the tables are.\n\nHere is what I get from printing\nout the AST for some examples:\n\nTREES FOR class T { public java.util.List<Integer> i,j[]; }\nECLIPSE AST\n0) class org.eclipse.jdt.core.dom.CompilationUnit 0 49 \n 1) class org.eclipse.jdt.core.dom.TypeDeclaration 0 49 \n  2) class org.eclipse.jdt.core.dom.SimpleName 6 1 \n  3) class org.eclipse.jdt.core.dom.FieldDeclaration 10 37 \n   4) class org.eclipse.jdt.core.dom.Modifier 10 6 \n   5) class org.eclipse.jdt.core.dom.ArrayType 17 23 <--- should not be an \narray of parameterized type\n    6) class org.eclipse.jdt.core.dom.ParameterizedType 17 23 \n     7) class org.eclipse.jdt.core.dom.SimpleType 17 14 \n      8) class org.eclipse.jdt.core.dom.QualifiedName 17 14 \n       9) class org.eclipse.jdt.core.dom.QualifiedName 17 9 \n        10) class org.eclipse.jdt.core.dom.SimpleName 17 4 \n        11) class org.eclipse.jdt.core.dom.SimpleName 22 4 \n       12) class org.eclipse.jdt.core.dom.SimpleName 27 4 \n     13) class org.eclipse.jdt.core.dom.SimpleType 32 7 \n      14) class org.eclipse.jdt.core.dom.SimpleName 32 7 \n   15) class org.eclipse.jdt.core.dom.VariableDeclarationFragment 41 1 \n    16) class org.eclipse.jdt.core.dom.SimpleName 41 1 \n   17) class org.eclipse.jdt.core.dom.VariableDeclarationFragment 43 3 \n    18) class org.eclipse.jdt.core.dom.SimpleName 43 1 \n\nThis one looks ok, but the type for j is still incorrectly an array type.\n\nTREES FOR class T { public java.util.List<Integer> i[],j; }\nECLIPSE AST\n0) class org.eclipse.jdt.core.dom.CompilationUnit 0 49 \n 1) class org.eclipse.jdt.core.dom.TypeDeclaration 0 49 \n  2) class org.eclipse.jdt.core.dom.SimpleName 6 1 \n  3) class org.eclipse.jdt.core.dom.FieldDeclaration 10 37 \n   4) class org.eclipse.jdt.core.dom.Modifier 10 6 \n   5) class org.eclipse.jdt.core.dom.ParameterizedType 17 23 \n    6) class org.eclipse.jdt.core.dom.SimpleType 17 14 \n     7) class org.eclipse.jdt.core.dom.QualifiedName 17 14 \n      8) class org.eclipse.jdt.core.dom.QualifiedName 17 9 \n       9) class org.eclipse.jdt.core.dom.SimpleName 17 4 \n       10) class org.eclipse.jdt.core.dom.SimpleName 22 4 \n      11) class org.eclipse.jdt.core.dom.SimpleName 27 4 \n    12) class org.eclipse.jdt.core.dom.SimpleType 32 7 \n     13) class org.eclipse.jdt.core.dom.SimpleName 32 7 \n   14) class org.eclipse.jdt.core.dom.VariableDeclarationFragment 41 3 \n    15) class org.eclipse.jdt.core.dom.SimpleName 41 1 \n   16) class org.eclipse.jdt.core.dom.VariableDeclarationFragment 45 1 \n    17) class org.eclipse.jdt.core.dom.SimpleName 45 1 \n\n\n- David",,,,
104655,, [1.5] inconsistent compiler behavior in generic methods  ,3.1.1,philippe_mulet@fr.ibm.com,normal,P3,37092.41597,37093.44012,1.024143519,58,"3.1\nmethod1 compiles, method2 fails. As far as I can tell, their typing should be\nthe same.\n\nclass Test {\n  <Sup, E1 extends Sup, E2 extends Sup> Sup method1(boolean b, E1 e1, E2 e2) {\n    if (b)\n      return e1;\n    else\n      return e2;\n  }\n\n  <Sup, E1 extends Sup, E2 extends Sup> Sup method2(boolean b, E1 e1, E2 e2) {\n    return b ? e1 : e2;\n  }\n}",,,,
103148,, [1.5][assist] Code completion breaks if using static method generics ( Class.<T>staticMethod(params) )  ,3.1.1,david_audel@fr.ibm.com,normal,P3,37079.29167,37083.46138,4.169710648,202,"Everytime I have to put a call to a generics-enabled static methods, code\ncompletion stops to work after the method call.\n\nGenerics syntax which broke the completion\nClass.<T>staticMethod(params);\n\nPseudo-example:\nEnumSet.<MyType>of(MyType.VALUE1, MyType.VALUE2);\n\nReal-example:\nEnumSet.<Mode>of(Mode.BINDING, Mode.READABLE, Mode.WRITABLE);\n\nSince this happens quite often for me (I'm very fond of generics enumset, they\nare sooooo handy & easy to use instead of the old error-prone untyped bitsets),\nit's quite a nuisance.\n\nAnyone can confirm this?\n\nP.s. thanks for this life-saving & deadline-saving tool! :D",,,,
104082,104065, [1.5][compiler] 1.5 source code gets internal eclipse null pointer error  ,3.1.1,philippe_mulet@fr.ibm.com,critical,P3,37086.63333,37089.34343,2.710092593,282,"We have a large 1.5 codebase and when we put it into the new version of eclipse \nwe found that one class wouldn't compile.  The issue was an internal eclipse \nnull pointer error and it just put the exception at the first line of one of \nour classes.  We were able to strip out all of the other classes and strip down \nthe broken class and found that one complex method seemed to be the cause.  \n\nThis class compiles fine using suns 1.5.0_02-b09 compiler.  We've tested this \non several diferent machines running eclipse 3.1 and we have eclipse set to \ncompile as a 1.5 file.  \n\neclipse version\nVersion: 3.1.0\nBuild id: I20050627-1435\n\n\nIf you would like more information about this or a screen print of the error \neclipse is giving please email me at jbienkowski@comcast.net\n\nHere is the class:\n\n\npackage com.mm.rs.jccs.ui.jccs;\n\nimport com.mm.rs.jccs.*;\nimport java.lang.reflect.*;\nimport java.util.*; \n\ninterface StoredObject {\n\tString getUid();\n\t\n\tString getName();\n\t\n\tString getDescription();\n\t\n}\n\ninterface GraphDiagramNode //extends Comparable\n{\n\n}\n\npublic class JccsGraphDiagramNode\n    <ObjectType extends StoredObject,\n     ParentType extends StoredObject>\n    implements GraphDiagramNode\n{\n    private final JccsGraphDiagramModel model;\n    private final JccsGraphDiagramNode<? extends ParentType, ?> parent;\n    private final ObjectType object;\n\n    public class JccsGraphDiagramModel \n    {\n    }\n \n    public interface GraphDiagramModel\n    {\n       \n    }\n    \n    public class Dependency\n    {\n     \n    }\n   \n    public JccsGraphDiagramNode(\n        JccsGraphDiagramModel argModel,\n        JccsGraphDiagramNode<? extends ParentType, ?> argParent,\n        ObjectType argObject)\n    {\n        model = argModel;\n        parent = argParent;\n        object = argObject;\n    }\n\n    protected\n        <ChildType extends StoredObject>\n        Collection<? extends JccsGraphDiagramNode<ChildType, ? super \nObjectType>> createChildren(\n            Iterator<ChildType> argData,\n            Class<? extends JccsGraphDiagramNode<ChildType, ? super \nObjectType>> argChildNodeClass,\n        Class<? extends StoredObject> argInterface)\n    {\n        Collection<JccsGraphDiagramNode<ChildType, ? super ObjectType>> output\n            = new LinkedList<JccsGraphDiagramNode<ChildType, ? super \nObjectType>>();\n\n        try\n        {\n            while (argData.hasNext())\n            {\n                ChildType next = argData.next();\n                Constructor<? extends JccsGraphDiagramNode<ChildType, ? super \nObjectType>>\n                    constructor = argChildNodeClass.getConstructor(\n                        JccsGraphDiagramModel.class,\n                        getClass(),\n                        argInterface);\n\n                output.add(constructor.newInstance(model, this, next));\n            }\n        }\n        catch (Exception x)\n        {\n            x.printStackTrace();\n        }\n\n        return output;\n    }\n}",,,,
108203,, [1.5][compiler] cannot compile internal class implementing interface with parameterized method  ,3.1.1,kent_johnson@ca.ibm.com,major,P3,37129.74792,37152.62125,22.87333333,594,"I have the following internal class:\n\npublic interface ValueRepresentationStrategy<V>\n{\n  public <N extends V> Component<?> createComponent(final TreeModel model, final\nTreeNodeModel<N> treeNode, final boolean editable, final boolean selected, final\nboolean focused);\n}\n\nThe following internal class in the same file will not compile, even though it\ncompiles under JDK 1.5.0_04:\n\npublic static class TestValueRepresentationStrategy implements\nValueRepresentationStrategy<LabelModel>\n{\n  public <N extends LabelModel> Component<?> createComponent(final TreeModel\nmodel, final TreeNodeModel<N> treeNode, final boolean editable, final boolean\nselected, final boolean focused)\n  {\n    return null;\n  }\n}\n\nChanging the class to the following allows it to compile:\n\npublic interface ValueRepresentationStrategy<V>\n{\n  public Component<?> createComponent(final TreeModel model, final\nTreeNodeModel<V> treeNode, final boolean editable, final boolean selected, final\nboolean focused);\n}",,,,
104695,, [1.5][compiler] Compiler allows instanceof with non-reifiable array type  ,3.1.1,philippe_mulet@fr.ibm.com,normal,P3,37092.56944,37138.52013,45.95068287,500,N20050721-0010\n\nclass Bug<E> {\n    void method(Object o) {\n        if (o instanceof E[]) { //incorrect: cannot test non-reifiable type\n            E[] es= (E[]) o,\n        }\n        if (o instanceof List<E>[]) { //incorrect too\n            List<E>[] es= (List<E>[]) o, \n        }\n    }\n},,
106106,, [1.5][compiler] Compiler error with Arrays.asList in Java 5 mode?  ,3.1.1,philippe_mulet@fr.ibm.com,critical,P3,37106.74097,37114.25988,7.518912037,38,"There seems to be a problem with the compiler (I think) that shows up in the\nArrays.toList method. \n\nThe following program displays the problem:  \n\nimport java.util.*; \n\npublic class foo {\n  public static void main(String[] args) {\n    double[][] d = { { 1 } , { 2 } }; \n    List l = Arrays.asList(d); \n    System.out.println(""List size: "" + l.size());\n  }\n}\n\nIn eclipse, I get the output: \n\n   List size: 1\n\nUsing the Java 5 compiler I get the expected: \n\n   List size: 2\n\n\nIt seems that the Eclipse compiler doesn't recognize a double[][] as an Object[]\nand so wraps it in a new Object[] containing the double[][]. If I add an\nexplicit cast to Object[] in eclipse I get the expected result: \n\npublic class foo {\n  public static void main(String[] args) {\n    double[][] d = { { 1 } , { 2 } }; \n    List l = Arrays.asList((Object[]) d); \n    System.out.println(""List size: "" + l.size());\n  }\n}\n\nList size: 2",,,,
108263,, [1.5][compiler] Constants initilialization doesn't work inside Annotation  ,3.1.1,philippe_mulet@fr.ibm.com,normal,P3,37131.38264,37139.32317,7.940532407,370,"build I20050823-0800 + jdtcore head\n\n1) create A.java\n\npublic @interface A {\n  public static final Integer foo = B.zzz; \n  public static final int foo3 = B.zzz2; \n}\nclass B {\n  public static final Integer zzz = new Integer(0);\n  public static final int zzz2 = 0;\n}\n2) compile\njdtcore compiler found one error\n""The annotation field A.foo must be initialized with a constant expression""\n\nand javac none",,,,
110570,, [1.5][compiler] error in type deduction  ,3.1.1,philippe_mulet@fr.ibm.com,normal,P3,37159.22153,37159.44619,0.224664352,73,"In the following code Eclipse 3.2M2 reports an error on t1.test()\n\n""The method test(Object, V1) in the type Tester is not applicable for the\narguments (A, B)""\n\nwhereas javac only reports an unchecked call.\n\n\nIMHO the compiler should not report anything.\n\n------------------------------------------------\npublic class Tester<T> {\n\n  public <V1, V2 extends V1> void test(V1 p1, V2 p2) {}\n\t\n  public static void main(String[] args) {\n    A a = new A() {};\n    B b = new B() {};\n\n    Tester t1 = new Tester();\n    t1.test(a, b); //this gives an error but should be OK\n    \n    Tester<Object> t2 = new Tester<Object>();\n    t2.test(a, b); //this compiles OK\n  }\n}\n\ninterface A {\n}\ninterface B extends A {\n}\n------------------------------------------------",,,,
100043,, [1.5][compiler] false compiler error on ?: ternary operator with boxing  ,3.1.1,philippe_mulet@fr.ibm.com,minor,P3,37055.60556,37077.23262,21.62706019,45,"The following code is perfectly legal in java 1.5, javac compiles it,\nand it runs.  It was not legal in java 1.4, and the Eclipse built-in \ncompiler flags line 5 as an error, with the message\n""Incompatible conditional operand types int and String""\n\npublic class Bug {\n  public static void main(String[] args) {\n    int foo = 0;\n    String bar = ""zero"";\n    System.out.println( (foo != 0) ? foo : bar );\n  }\n}",,,,
102181,, [1.5][compiler] Generic varargs are built with incorrect array type  ,3.1.1,philippe_mulet@fr.ibm.com,major,P3,37070.58333,37075.15473,4.571400463,2,"The basic problem is that when building the varargs for A... args where A has\nbeen specified as String, the compiler is ignoring the specified type and\nbuilding an array of Objects instead.\n\nNote that this behaviour has been introduced since at least Eclipse 3.1rc1.\n\nThis causes a ClassCastException in the following code:\npublic class MyTest {\n\n    public static void main(String[] args) {\n        Test<String> t = new Tester();\n        t.method(""1st string"");\n    }\n    \n    static abstract class Test<A> {\n        abstract void method(A... args);\n    }\n    \n    static class Tester extends Test<String> {\n\n        void method(String... args) {\n            System.out.println(args);\n            call(args);\n        }\n        \n        void call(String[] args) {\n            for ( String str : args )\n                System.out.println(""String: ""+str);\n        }\n    }\n    \n}\n\nthe exact output when compiled with Eclipse 3.1 is:\nException in thread ""main"" java.lang.ClassCastException: [Ljava.lang.Object;\n\tat MyTest$Tester.method(MyTest.java:1)\n\tat MyTest.main(MyTest.java:10)\n\nwhen compiled using Eclipse 3.1rc1, or javac from Sun's JDK1.5.0_01 the output\nis as I would expect:\n[Ljava.lang.String;@360be0\nString: 1st string\n\nI don't know which is the ""correct"" result, but if the latest Eclipse is then I\nwould expect a compiler warning or error, rather than a run-time ClassCastException.",,,,
104167,, [1.5][compiler] incorrect 'unread field' diagnosis  ,3.1.1,philippe_mulet@fr.ibm.com,normal,P3,37088.91319,37089.31051,0.397314815,282,"3.1\nif A is not generic, then the warning goes away\n\npublic class A<T> {\n  private static class B{\n    private int foo; //incorrectly identified as unused\n  }\n  void bar(B b){\n    if (b.foo == 0)\n      return;\n  }\n}",,,,
108372,, [1.5][compiler] Inner class of enclosing raw type don't works  ,3.1.1,philippe_mulet@fr.ibm.com,normal,P3,37132.4375,37140.38377,7.946273148,178,the following code doesn't compile because\ninner is typed Foo<T>.Inner and not\nFoo.Inner. It's works with Foo<?>.Inner\n\npublic class Foo<T> {\n    private T t,\n    private Foo.Inner[] inner,\n    public Foo(T t) {\n        this.t = t,\n        inner = new Foo.Inner[10],\n        //Type mismatch: cannot convert from Foo.Inner[] to Foo<T>.Inner[]\n    }\n    private class Inner {\n    }\n}\n\nRÃ©mi Forax
110563,, [1.5][compiler] Internal compiler error for varags  ,3.1.1,philippe_mulet@fr.ibm.com,major,P3,37159.14028,37159.4255,0.285219907,9,"The following code causes an internal compiler error for Eclipse 3.2 M1 and 3.2\nM2. It works fine in Eclipse 3.1 RC1.\n\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collection;\n\nimport junit.framework.TestCase;\n\n/**\n * @author Pekka Enberg\n */\npublic class BreakEclipseTest extends TestCase {\n    public void testBreak() {\n        Collection<Class> classes = new ArrayList<Class>();\n        assertEquals(3, classes.size());\n        assertTrue(classes.containsAll(Arrays.asList(String.class,\nInteger.class, Long.class)));\n    }\n}\n\nThe error is:\n\nError 2005-09-26 10:21:18.198 Error in JDT Core during AST creation\njava.lang.NullPointerException\nat org.eclipse.jdt.internal.compiler.lookup.Scope.lowerUpperBound(Scope.java:2965)\nat\norg.eclipse.jdt.internal.compiler.lookup.Scope.leastContainingTypeArgument(Scope.java:2927)\nat\norg.eclipse.jdt.internal.compiler.lookup.Scope.leastContainingInvocation(Scope.java:2845)\nat org.eclipse.jdt.internal.compiler.lookup.Scope.lowerUpperBound(Scope.java:2985)\nat org.eclipse.jdt.internal.compiler.lookup.Scope.lowerUpperBound(Scope.java:2945)\nat\norg.eclipse.jdt.internal.compiler.lookup.ParameterizedGenericMethodBinding.resolveSubstituteConstraints(ParameterizedGenericMethodBinding.java:245)\nat\norg.eclipse.jdt.internal.compiler.lookup.ParameterizedGenericMethodBinding.inferFromArgumentTypes(ParameterizedGenericMethodBinding.java:167)\nat\norg.eclipse.jdt.internal.compiler.lookup.ParameterizedGenericMethodBinding.computeCompatibleMethod(ParameterizedGenericMethodBinding.java:63)\nat\norg.eclipse.jdt.internal.compiler.lookup.Scope.computeCompatibleMethod(Scope.java:358)\nat org.eclipse.jdt.internal.compiler.lookup.Scope.findMethod(Scope.java:1118)\nat org.eclipse.jdt.internal.compiler.lookup.Scope.getMethod(Scope.java:2102)\nat\norg.eclipse.jdt.internal.compiler.ast.MessageSend.resolveType(MessageSend.java:314)\nat\norg.eclipse.jdt.internal.compiler.ast.MessageSend.resolveType(MessageSend.java:291)\nat\norg.eclipse.jdt.internal.compiler.ast.MessageSend.resolveType(MessageSend.java:291)\nat org.eclipse.jdt.internal.compiler.ast.Expression.resolve(Expression.java:829)\nat\norg.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolveStatements(AbstractMethodDeclaration.java:418)\nat\norg.eclipse.jdt.internal.compiler.ast.MethodDeclaration.resolveStatements(MethodDeclaration.java:177)\nat\norg.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:396)\nat\norg.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1082)\nat\norg.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1131)\nat\norg.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:305)\nat\norg.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:821)\nat\norg.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:498)\nat org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:789)\nat org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:588)\nat org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:566)\nat\norg.eclipse.core.internal.runtime.InternalPlatform.run(InternalPlatform.java:1044)\nat org.eclipse.core.runtime.Platform.run(Platform.java:783)\nat\norg.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:563)\nat org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:493)\nat\norg.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.getClipboardData(ClipboardOperationAction.java:393)\nat\norg.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.doCutCopyWithImportsOperation(ClipboardOperationAction.java:322)\nat\norg.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.internalDoOperation(ClipboardOperationAction.java:278)\nat\norg.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction$1.run(ClipboardOperationAction.java:247)\nat org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:69)\nat\norg.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.run(ClipboardOperationAction.java:245)\nat org.eclipse.jface.action.Action.runWithEvent(Action.java:996)\nat org.eclipse.ui.commands.ActionHandler.execute(ActionHandler.java:182)\nat\norg.eclipse.ui.internal.handlers.LegacyHandlerWrapper.execute(LegacyHandlerWrapper.java:108)\nat org.eclipse.core.commands.Command.execute(Command.java:311)\nat\norg.eclipse.core.commands.ParameterizedCommand.execute(ParameterizedCommand.java:397)\nat\norg.eclipse.ui.internal.keys.WorkbenchKeyboard.executeCommand(WorkbenchKeyboard.java:459)\nat org.eclipse.ui.internal.keys.WorkbenchKeyboard.press(WorkbenchKeyboard.java:781)\nat\norg.eclipse.ui.internal.keys.WorkbenchKeyboard.processKeyEvent(WorkbenchKeyboard.java:828)\nat\norg.eclipse.ui.internal.keys.WorkbenchKeyboard.filterKeySequenceBindings(WorkbenchKeyboard.java:550)\nat\norg.eclipse.ui.internal.keys.WorkbenchKeyboard.access$3(WorkbenchKeyboard.java:493)\nat\norg.eclipse.ui.internal.keys.WorkbenchKeyboard$KeyDownFilter.handleEvent(WorkbenchKeyboard.java:117)\nat org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:66)\nat org.eclipse.swt.widgets.Display.filterEvent(Display.java:1244)\nat org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1049)\nat org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1074)\nat org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1059)\nat org.eclipse.swt.widgets.Widget.sendKeyEvent(Widget.java:1086)\nat org.eclipse.swt.widgets.Widget.gtk_key_press_event(Widget.java:640)\nat org.eclipse.swt.widgets.Control.gtk_key_press_event(Control.java:1965)\nat org.eclipse.swt.widgets.Composite.gtk_key_press_event(Composite.java:564)\nat org.eclipse.swt.widgets.Widget.windowProc(Widget.java:1395)\nat org.eclipse.swt.widgets.Display.windowProc(Display.java:3490)\nat org.eclipse.swt.internal.gtk.OS._gtk_main_do_event(Native Method)\nat org.eclipse.swt.internal.gtk.OS.gtk_main_do_event(OS.java:4891)\nat org.eclipse.swt.widgets.Display.eventProc(Display.java:1059)\nat org.eclipse.swt.internal.gtk.OS._g_main_context_iteration(Native Method)\nat org.eclipse.swt.internal.gtk.OS.g_main_context_iteration(OS.java:1271)\nat org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:2603)\nat org.eclipse.ui.internal.Workbench.runEventLoop(Workbench.java:1755)\nat org.eclipse.ui.internal.Workbench.runUI(Workbench.java:1719)\nat org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:368)\nat org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:143)\nat org.eclipse.ui.internal.ide.IDEApplication.run(IDEApplication.java:106)\nat\norg.eclipse.core.internal.runtime.PlatformActivator$1.run(PlatformActivator.java:226)\nat org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:377)\nat org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:164)\nat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\nat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)\nat\nsun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)\nat java.lang.reflect.Method.invoke(Method.java:585)\nat org.eclipse.core.launcher.Main.invokeFramework(Main.java:338)\nat org.eclipse.core.launcher.Main.basicRun(Main.java:282)\nat org.eclipse.core.launcher.Main.run(Main.java:977)\nat org.eclipse.core.launcher.Main.main(Main.java:952)",,,,
110738,, [1.5][compiler] Internal compiler error while processing Currency  ,3.1.1,kent_johnson@ca.ibm.com,normal,P3,37159.74583,37160.56052,0.8146875,6,"Build 3.1.1rc2\n\nWhen compiling java/util/Currency.java from sources 1.6 against JRE1.6, the\ncompiler terminates with following exception:\n\nSeverity\tDescription\tResource\tIn Folder\tLocation\tCreation Time\tId\n2\tInternal compiler error\njava.lang.ArrayIndexOutOfBoundsException: 3\n\tat\norg.eclipse.jdt.internal.compiler.lookup.Scope.parameterCompatibilityLevel(Scope.java:3494)\n\tat org.eclipse.jdt.internal.compiler.lookup.Scope.findMethod(Scope.java:1211)\n\tat org.eclipse.jdt.internal.compiler.lookup.Scope.getMethod(Scope.java:2102)\n\tat\norg.eclipse.jdt.internal.compiler.ast.MessageSend.resolveType(MessageSend.java:314)\n\tat\norg.eclipse.jdt.internal.compiler.ast.LocalDeclaration.resolve(LocalDeclaration.java:199)\n\tat org.eclipse.jdt.internal.compiler.ast.Block.resolve(Block.java:101)\n\tat org.eclipse.jdt.internal.compiler.ast.IfStatement.resolve(IfStatement.java:225)\n\tat org.eclipse.jdt.internal.compiler.ast.Block.resolveUsing(Block.java:115)\n\tat\norg.eclipse.jdt.internal.compiler.ast.TryStatement.resolve(TryStatement.java:504)\n\tat\norg.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolveStatements(AbstractMethodDeclaration.java:418)\n\tat\norg.eclipse.jdt.internal.compiler.ast.MethodDeclaration.resolveStatements(MethodDeclaration.java:178)\n\tat\norg.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:396)\n\tat\norg.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1072)\n\tat\norg.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1121)\n\tat\norg.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:305)\n\tat org.eclipse.jdt.internal.compiler.Compiler.process(Compiler.java:512)\n\tat org.eclipse.jdt.internal.compiler.Compiler.compile(Compiler.java:329)\n\tat\norg.eclipse.jdt.internal.core.builder.AbstractImageBuilder.compile(AbstractImageBuilder.java:248)\n\tat\norg.eclipse.jdt.internal.core.builder.AbstractImageBuilder.compile(AbstractImageBuilder.java:221)\n\tat\norg.eclipse.jdt.internal.core.builder.BatchImageBuilder.build(BatchImageBuilder.java:50)\n\tat org.eclipse.jdt.internal.core.builder.JavaBuilder.buildAll(JavaBuilder.java:213)\n\tat org.eclipse.jdt.internal.core.builder.JavaBuilder.build(JavaBuilder.java:136)\n\tat org.eclipse.core.internal.events.BuildManager$2.run(BuildManager.java:593)\n\tat\norg.eclipse.core.internal.runtime.InternalPlatform.run(InternalPlatform.java:1044)\n\tat org.eclipse.core.runtime.Platform.run(Platform.java:783)\n\tat org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:168)\n\tat org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:202)\n\tat org.eclipse.core.internal.events.BuildManager$1.run(BuildManager.java:231)\n\tat\norg.eclipse.core.internal.runtime.InternalPlatform.run(InternalPlatform.java:1044)\n\tat org.eclipse.core.runtime.Platform.run(Platform.java:783)\n\tat org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:234)\n\tat\norg.eclipse.core.internal.events.BuildManager.basicBuildLoop(BuildManager.java:253)\n\tat org.eclipse.core.internal.events.BuildManager.build(BuildManager.java:282)\n\tat org.eclipse.core.internal.resources.Workspace.build(Workspace.java:211)\n\tat org.eclipse.ui.actions.GlobalBuildAction$1.run(GlobalBuildAction.java:182)\n\tat org.eclipse.core.internal.jobs.Worker.run(Worker.java:76)\n\tCurrency.java\tJRE Source libs 1.6/src/java/util\tline 0\tSeptember 26, 2005\n11:11:52 PM\t10068114",,,,
107681,, [1.5][compiler] invalid ambiguous invocation diagnostic  ,3.1.1,kent_johnson@ca.ibm.com,normal,P3,37124.82361,37152.62108,27.79746528,594,"The 3.1 compiler complains about the invocation of erasure claiming the\ninvocation is ambiguous. This isn't possible since the method must be an override.\n\nimport java.lang.reflect.Type;\n\ninterface Navigator<TypeT> {\n\t<T> TypeT erasure(TypeT x);\n}\n\nclass ReflectionNavigator implements Navigator<Type> {\n\tpublic <T> Class<T> erasure(Type t) { return null; }\n}\n\nclass Usage {\n\tpublic void foo(ReflectionNavigator r, Type t) {\n\t\tr.erasure(t);\n\t}\n}",,,,
107756,, [1.5][compiler] Invalid diagnostic invoking method through raw interface  ,3.1.1,philippe_mulet@fr.ibm.com,normal,P3,37125.56597,37135.29848,9.732511574,106,"The compiler is issuing an invalid diagnostic saying ""cannot convert from\nUnmarshaller.Handler to Unmarshaller.Handler"" when assigning to h.\n\n\ninterface Prop<BeanT> {\n\tUnmarshaller.Handler createHandler();\n}\n\nabstract class Unmarshaller {\n\tpublic static abstract class Handler {}\n}\n\nclass X {\n\tvoid foo(Prop p) {\n\t\tUnmarshaller.Handler h = p.createHandler(); \n\t}\n}",,,,
107098,, [1.5][compiler] method override check fails with instantiated type parameter in bound  ,3.1.1,kent_johnson@ca.ibm.com,normal,P3,37118.25,37152.62097,34.37097222,594,"I20050811-1530 + jdt.core v_606\n\nclass A<T> {\n    <S extends T> void foo2(Number t, S s) { System.out.println(""A""); }\n}\n\nclass B extends A<Number> {\n    @Override //eclipse: foo2(..) must override a superclass method\n    <S extends Number> void foo2(Number t, S s) { System.out.println(""B""); }\n}\n\npublic class Test {\n    public static void main(String[] args) {\n        B b= new B();\n        b.foo2(1, 10); //eclipse: ambiguous\n        A<Number> a= b;\n        a.foo2(2, 20);\n    }\n}\n\nJavac 1.5.0_04 gives no errors, which seems correct.",,,,
104551,, [1.5][compiler] Method override checks fail with raw subtype and type variable as type bound  ,3.1.1,philippe_mulet@fr.ibm.com,normal,P3,37091.60347,37092.38037,0.776898148,188,"I20050627-1435 (3.1)\n\nMethod override checks fail with raw subtype and type variable as type bound.\nJavac accepts these classes, which is IMO correct.\n\ninterface IStructuredContentProvider<I, E extends I> {\n    public E[] getElements(I inputElement);\n    public E[] getChildren(E parent);\n}\n\nclass MyContentProvider implements IStructuredContentProvider {\n// eclipse error: The type MyContentProvider must implement the inherited\n// abstract method IStructuredContentProvider.getChildren(I)\n\n    public Object[] getElements(Object inputElement) {\n        // eclipse error: The return type is incompatible with\n        // IStructuredContentProvider.getElements(Object)\n        return null;\n    }\n\n    public Object[] getChildren(Object parent) {\n        // eclipse error: Name clash: The method getChildren(Object) of type\n        // MyContentProvider has the same erasure as getChildren(E) of type\n        // IStructuredContentProvider<I,E> but does not override it\n        return null;\n    }\n}",,,,
104649,, [1.5][compiler] method type variable: inference broken for null  ,3.1.1,philippe_mulet@fr.ibm.com,minor,P3,37092.39861,37094.82751,2.428900463,134,"N20050721-0010\n\npublic class Try {\n\tvoid shouldcompile() {\n\t\tjava.util.Collections.max(null);\n\t}\n}\n\nThe eclipse compiler rejects with error:\n""Bound mismatch: The generic method max(Collection<? extends T>) of type\nCollections is not applicable for the arguments (Collection<? extends\nComparable<? super T>>) since the type Comparable<? super T> is not a valid\nsubstitute for the bounded parameter <T extends Object & Comparable<? super T>>""\n\njavac bug: http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=6299211",,,,
107079,, [1.5][compiler] mis-compiled Wildcard capture leads to a ClassCastException  ,3.1.1,philippe_mulet@fr.ibm.com,normal,P3,37117.80208,37121.45274,3.650659722,148,"My understanding is that a method with a signature of the form (A< B< T> > p)\nshould not allow a capture-conversion when passed a parameter of type A< B<?> >\n- since the wildcard is not first-level. (Not quite sure If I have the\nterminology right here). If it does allow such a conversion, a\nClassCastException may follow.\n\nHere is code that compiles under eclipse 3.1.0 (release), but not under Sun's\njavac. I believe the behaviour of Sun's javac is correct - although the JLS\ncontent might be slightly questionable in the area of capture conversion. This\ncode compiles under eclipse, and when run, throws a ClassCastException (Despite\nthere being no explicit casts)\n<pre>\n//This compilation unit is released in the public domain.\npackage typeBug;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\n/** \n * This class demonstrates a generic program that Eclipse must not compile as \n * it can lead to a ClassCastException despite having no explicit type casts.\n */\npublic class TypeBug\n{\n   private static class ValueHolder<T>\n   {\n      public T value;\n   }\n   \n   public static void main(final String[] args)\n   {\n      List< ValueHolder<?> > multiList = new ArrayList< ValueHolder<?> >();\n      \n      ValueHolder<Integer> intHolder = new ValueHolder<Integer>();\n      intHolder.value = 1;\n      \n      ValueHolder<Double> doubleHolder = new ValueHolder<Double>();\n      doubleHolder.value = 1.5;\n      \n      multiList.add(intHolder);\n      multiList.add(doubleHolder);\n      \n      // I believe this line is being erroneously treated as a capture\nconversion under 3.1 JDT.\n      // I believe the problem is that ? cannot be captured except in a first\nlevel wildcard.\n      swapFirstTwoValues(multiList);\n      \n      // this line causes a ClassCastException when checked.\n      Integer value = intHolder.value;\n      System.out.println(value);\n   }\n   \n   private static <T> void swapFirstTwoValues(List< ValueHolder<T> > multiList)\n   {\n      ValueHolder<T> intHolder = multiList.get(0);\n      ValueHolder<T> doubleHolder = multiList.get(1);\n      \n      intHolder.value = doubleHolder.value;\n   }\n}\n</pre>\n\nHere is the error message Sun's javac gives:\ntypeBug/TypeBug.java:33:\n<T>swapFirstTwoValues(java.util.List<typeBug.TypeBug.ValueHolder<T>>) in\ntypeBug.TypeBug cannot be applied to\n(java.util.List<typeBug.TypeBug.ValueHolder<?>>)\n      swapFirstTwoValues(multiList);\n      ^\n1 error",,,,
106297,, [1.5][compiler] new A<X>().new B(){}  ,3.1.1,philippe_mulet@fr.ibm.com,major,P3,37109.15972,37110.35616,1.196435185,72,"The Sun javac accepts this; Eclipse does not.\n\nclass A<T> { \n\tclass B { }\n\tstatic { \n\t\tnew A<String>().new B() {};\n\t}\n}\n\nThe complation fails with the message ""No enclosing instance of type A<T> is accessible. Must qualify \nthe allocation with an enclosing instance of type A<T> (e.g. x.new A() where x is an instance of A<T>).""",,,,
108783,, [1.5][compiler] Runnable masks Iterable interface in bounds  ,3.1.1,philippe_mulet@fr.ibm.com,normal,P3,37138.26736,37142.55609,4.288726852,1370,"The following code should print:\na\nb\non the standard output stream.\nInstead, we get an error:\nclass file for X.java:\njava.lang.NoSuchMethodError: java.lang.Runnable.iterator()Ljava/util/Iterator;\n\tat X.foo(X.java:7)\n\tat X.main(X.java:17)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n...\n\nSource file:\nimport java.util.Arrays;\nimport java.util.Iterator;\nimport java.util.List;\n\npublic class X implements Iterable<String>, Runnable {\n\tpublic <T extends Runnable & Iterable<String>> void foo(T t) {\n\t\tfor (String s : t)\n\t\t\tSystem.out.println(s);\n\t}\n\tpublic void run() {\t/* */ }\n\tprivate List<String> list = Arrays.asList(new String[] { ""a"", ""b"" });\n\tpublic Iterator<String> iterator() {\n\t\treturn this.list.iterator();\n\t}\n\tpublic static void main(String... args) {\n\t\tX x = new X();\n\t\tx.foo(x);\n\t}\n}\n\n(Prepared test case GenericTypeTest#test810, tested against 3.1 maintenance\nbranch today.)",,,,
103472,, [1.5][compiler] Should detect incompatible super interfaces  ,3.1.1,philippe_mulet@fr.ibm.com,normal,P3,37083.32778,37083.45486,0.127083333,354,Build 3.1.0\n\nScenario documented at:\nhttp://forum.java.sun.com/thread.jspa?forumID=316&threadID=642709\n\nexposes a situation where Eclipse doesn't flag a supertype collision.,,,,
103023,, [1.5][compiler] StackOverflow inferring type arguments  ,3.1.1,philippe_mulet@fr.ibm.com,normal,P3,37078.45972,37078.46179,0.002071759,60,"Build 3.1.0\n\nThe following code yields an infinite regression during type inference:\nimport java.util.*;\n\nclass X<T extends Comparable<? super T>> {\n\n    abstract class Foo<E> implements I<Foo<? extends E>> {}\n    abstract class Bar<E> implements I<Bar<? extends E>> {}\n\n    public void bar(List<Foo<T>> f, List<Bar<T>> b) {\n\tfoo(f, b);\n    }\n\n    <C> void foo(List<? extends C> f, List<? extends C> b) {\n\tSystem.out.println(""SUCCESS"");\n    }\n    public static void main(String... args) {\n\tnew X().bar(null, null);\n    }\n}\ninterface I<U> {}",,,,
108740,, [1.5][compiler] Type hierarchy with generics fails with NPE  ,3.1.1,kent_johnson@ca.ibm.com,major,P3,37135.99792,37159.6489,23.6509838,133,"Given the classes:\n\npublic class A<T> {}\npublic class B<T> extends A<C> {}\npublic class C extends B<C> {}\npublic class D extends B<D> {}\n\nrequesting a type hierarchy (F4) for D produces an NPE (stack trace below).\n\nThis is similar to bug 108378, which was fixed with 3.2M1, but this situation \nfails under 3.2M1.\n\nStack trace:\n\njava.lang.reflect.InvocationTargetException\nat org.eclipse.jface.operation.ModalContext.run(ModalContext.java:327)\nat org.eclipse.jface.window.ApplicationWindow$1.run(ApplicationWindow.java:631)\nat org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:69)\nat org.eclipse.jface.window.ApplicationWindow.run(ApplicationWindow.java:628)\nat org.eclipse.ui.internal.WorkbenchWindow.run(WorkbenchWindow.java:2138)\nat \norg.eclipse.jdt.internal.ui.typehierarchy.TypeHierarchyLifeCycle.ensureRefreshe\ndTypeHierarchy(TypeHierarchyLifeCycle.java:107)\nat org.eclipse.jdt.internal.ui.typehierarchy.TypeHierarchyViewPart.updateInput\n(TypeHierarchyViewPart.java:520)\nat \norg.eclipse.jdt.internal.ui.typehierarchy.TypeHierarchyViewPart.setInputElement\n(TypeHierarchyViewPart.java:484)\nat org.eclipse.jdt.internal.ui.util.OpenTypeHierarchyUtil.openInViewPart\n(OpenTypeHierarchyUtil.java:98)\nat org.eclipse.jdt.internal.ui.util.OpenTypeHierarchyUtil.open\n(OpenTypeHierarchyUtil.java:75)\nat org.eclipse.jdt.ui.actions.OpenTypeHierarchyAction.run\n(OpenTypeHierarchyAction.java:196)\nat org.eclipse.jdt.ui.actions.OpenTypeHierarchyAction.run\n(OpenTypeHierarchyAction.java:151)\nat org.eclipse.jdt.ui.actions.SelectionDispatchAction.dispatchRun\n(SelectionDispatchAction.java:226)\nat org.eclipse.jdt.ui.actions.SelectionDispatchAction.run\n(SelectionDispatchAction.java:198)\nat org.eclipse.jface.action.Action.runWithEvent(Action.java:996)\nat org.eclipse.ui.commands.ActionHandler.execute(ActionHandler.java:182)\nat org.eclipse.ui.internal.handlers.LegacyHandlerWrapper.execute\n(LegacyHandlerWrapper.java:108)\nat org.eclipse.core.commands.Command.execute(Command.java:311)\nat org.eclipse.core.commands.ParameterizedCommand.execute\n(ParameterizedCommand.java:396)\nat org.eclipse.ui.internal.keys.WorkbenchKeyboard.executeCommand\n(WorkbenchKeyboard.java:459)\nat org.eclipse.ui.internal.keys.WorkbenchKeyboard.press\n(WorkbenchKeyboard.java:781)\nat org.eclipse.ui.internal.keys.WorkbenchKeyboard.processKeyEvent\n(WorkbenchKeyboard.java:828)\nat org.eclipse.ui.internal.keys.WorkbenchKeyboard.filterKeySequenceBindings\n(WorkbenchKeyboard.java:550)\nat org.eclipse.ui.internal.keys.WorkbenchKeyboard.access$3\n(WorkbenchKeyboard.java:493)\nat org.eclipse.ui.internal.keys.WorkbenchKeyboard$KeyDownFilter.handleEvent\n(WorkbenchKeyboard.java:117)\nat org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:66)\nat org.eclipse.swt.widgets.Display.filterEvent(Display.java:920)\nat org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:867)\nat org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:892)\nat org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:877)\nat org.eclipse.swt.widgets.Widget.sendKeyEvent(Widget.java:905)\nat org.eclipse.swt.widgets.Widget.sendKeyEvent(Widget.java:901)\nat org.eclipse.swt.widgets.Widget.wmKeyDown(Widget.java:1500)\nat org.eclipse.swt.widgets.Control.WM_KEYDOWN(Control.java:3376)\nat org.eclipse.swt.widgets.Control.windowProc(Control.java:3087)\nat org.eclipse.swt.widgets.Display.windowProc(Display.java:3773)\nat org.eclipse.swt.internal.win32.OS.DispatchMessageW(Native Method)\nat org.eclipse.swt.internal.win32.OS.DispatchMessage(OS.java:1680)\nat org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:2763)\nat org.eclipse.ui.internal.Workbench.runEventLoop(Workbench.java:1734)\nat org.eclipse.ui.internal.Workbench.runUI(Workbench.java:1698)\nat org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:367)\nat org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:143)\nat org.eclipse.ui.internal.ide.IDEApplication.run(IDEApplication.java:103)\nat org.eclipse.core.internal.runtime.PlatformActivator$1.run\n(PlatformActivator.java:226)\nat org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:376)\nat org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:163)\nat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\nat sun.reflect.NativeMethodAccessorImpl.invoke(Unknown Source)\nat sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source)\nat java.lang.reflect.Method.invoke(Unknown Source)\nat org.eclipse.core.launcher.Main.invokeFramework(Main.java:338)\nat org.eclipse.core.launcher.Main.basicRun(Main.java:282)\nat org.eclipse.core.launcher.Main.run(Main.java:977)\nat org.eclipse.core.launcher.Main.main(Main.java:952)\nCaused by: java.lang.NullPointerException\nat \norg.eclipse.jdt.internal.compiler.lookup.ClassScope.checkForInheritedMemberType\ns(ClassScope.java:662)\nat org.eclipse.jdt.internal.compiler.lookup.ClassScope.connectTypeHierarchy\n(ClassScope.java:946)\nat \norg.eclipse.jdt.internal.compiler.lookup.CompilationUnitScope.connectTypeHierar\nchy(CompilationUnitScope.java:258)\nat \norg.eclipse.jdt.internal.compiler.lookup.LookupEnvironment.completeTypeBindings\n(LookupEnvironment.java:251)\nat org.eclipse.jdt.internal.core.hierarchy.HierarchyResolver.accept\n(HierarchyResolver.java:153)\nat org.eclipse.jdt.internal.compiler.lookup.LookupEnvironment.askForType\n(LookupEnvironment.java:131)\nat org.eclipse.jdt.internal.compiler.lookup.PackageBinding.getTypeOrPackage\n(PackageBinding.java:178)\nat org.eclipse.jdt.internal.compiler.lookup.Scope.getTypeOrPackage\n(Scope.java:2427)\nat org.eclipse.jdt.internal.compiler.lookup.Scope.getType(Scope.java:2166)\nat org.eclipse.jdt.internal.compiler.ast.SingleTypeReference.getTypeBinding\n(SingleTypeReference.java:39)\nat org.eclipse.jdt.internal.compiler.ast.TypeReference.resolveType\n(TypeReference.java:141)\nat org.eclipse.jdt.internal.compiler.ast.TypeReference.resolveTypeArgument\n(TypeReference.java:158)\nat \norg.eclipse.jdt.internal.compiler.ast.ParameterizedSingleTypeReference.internal\nResolveType(ParameterizedSingleTypeReference.java:136)\nat \norg.eclipse.jdt.internal.compiler.ast.ParameterizedSingleTypeReference.resolveT\nype(ParameterizedSingleTypeReference.java:223)\nat org.eclipse.jdt.internal.compiler.ast.TypeReference.resolveSuperType\n(TypeReference.java:104)\nat org.eclipse.jdt.internal.compiler.lookup.ClassScope.findSupertype\n(ClassScope.java:1097)\nat org.eclipse.jdt.internal.compiler.lookup.ClassScope.connectSuperclass\n(ClassScope.java:757)\nat org.eclipse.jdt.internal.compiler.lookup.ClassScope.connectTypeHierarchy\n(ClassScope.java:937)\nat \norg.eclipse.jdt.internal.compiler.lookup.CompilationUnitScope.connectTypeHierar\nchy(CompilationUnitScope.java:258)\nat \norg.eclipse.jdt.internal.compiler.lookup.LookupEnvironment.completeTypeBindings\n(LookupEnvironment.java:251)\nat org.eclipse.jdt.internal.core.hierarchy.HierarchyResolver.accept\n(HierarchyResolver.java:153)\nat org.eclipse.jdt.internal.compiler.lookup.LookupEnvironment.askForType\n(LookupEnvironment.java:131)\nat org.eclipse.jdt.internal.compiler.lookup.PackageBinding.getTypeOrPackage\n(PackageBinding.java:178)\nat org.eclipse.jdt.internal.compiler.lookup.Scope.getTypeOrPackage\n(Scope.java:2427)\nat org.eclipse.jdt.internal.compiler.lookup.Scope.getType(Scope.java:2166)\nat \norg.eclipse.jdt.internal.compiler.ast.ParameterizedSingleTypeReference.internal\nResolveType(ParameterizedSingleTypeReference.java:98)\nat \norg.eclipse.jdt.internal.compiler.ast.ParameterizedSingleTypeReference.resolveT\nype(ParameterizedSingleTypeReference.java:223)\nat org.eclipse.jdt.internal.compiler.ast.TypeReference.resolveSuperType\n(TypeReference.java:104)\nat org.eclipse.jdt.internal.compiler.lookup.ClassScope.findSupertype\n(ClassScope.java:1097)\nat org.eclipse.jdt.internal.compiler.lookup.ClassScope.connectSuperclass\n(ClassScope.java:757)\nat org.eclipse.jdt.internal.compiler.lookup.ClassScope.connectTypeHierarchy\n(ClassScope.java:937)\nat \norg.eclipse.jdt.internal.compiler.lookup.CompilationUnitScope.connectTypeHierar\nchy(CompilationUnitScope.java:258)\nat \norg.eclipse.jdt.internal.compiler.lookup.LookupEnvironment.completeTypeBindings\n(LookupEnvironment.java:251)\nat org.eclipse.jdt.internal.core.hierarchy.HierarchyResolver.resolve\n(HierarchyResolver.java:653)\nat \norg.eclipse.jdt.internal.core.hierarchy.IndexBasedHierarchyBuilder.buildForProj\nect(IndexBasedHierarchyBuilder.java:197)\nat \norg.eclipse.jdt.internal.core.hierarchy.IndexBasedHierarchyBuilder.buildFromPot\nentialSubtypes(IndexBasedHierarchyBuilder.java:304)\nat org.eclipse.jdt.internal.core.hierarchy.IndexBasedHierarchyBuilder.build\n(IndexBasedHierarchyBuilder.java:130)\nat org.eclipse.jdt.internal.core.hierarchy.TypeHierarchy.compute\n(TypeHierarchy.java:320)\nat org.eclipse.jdt.internal.core.hierarchy.TypeHierarchy.refresh\n(TypeHierarchy.java:1255)\nat org.eclipse.jdt.internal.core.CreateTypeHierarchyOperation.executeOperation\n(CreateTypeHierarchyOperation.java:90)\nat org.eclipse.jdt.internal.core.JavaModelOperation.run\n(JavaModelOperation.java:718)\nat org.eclipse.jdt.internal.core.JavaModelOperation.runOperation\n(JavaModelOperation.java:777)\nat org.eclipse.jdt.internal.core.SourceType.newTypeHierarchy\n(SourceType.java:716)\nat \norg.eclipse.jdt.internal.ui.typehierarchy.TypeHierarchyLifeCycle.createTypeHier\narchy(TypeHierarchyLifeCycle.java:118)\nat \norg.eclipse.jdt.internal.ui.typehierarchy.TypeHierarchyLifeCycle.doHierarchyRef\nresh(TypeHierarchyLifeCycle.java:157)\nat org.eclipse.jdt.internal.ui.typehierarchy.TypeHierarchyLifeCycle$1.run\n(TypeHierarchyLifeCycle.java:98)\nat org.eclipse.jface.operation.ModalContext$ModalContextThread.run\n(ModalContext.java:113)\nRoot exception:\njava.lang.NullPointerException\nat \norg.eclipse.jdt.internal.compiler.lookup.ClassScope.checkForInheritedMemberType\ns(ClassScope.java:662)\nat org.eclipse.jdt.internal.compiler.lookup.ClassScope.connectTypeHierarchy\n(ClassScope.java:946)\nat \norg.eclipse.jdt.internal.compiler.lookup.CompilationUnitScope.connectTypeHierar\nchy(CompilationUnitScope.java:258)\nat \norg.eclipse.jdt.internal.compiler.lookup.LookupEnvironment.completeTypeBindings\n(LookupEnvironment.java:251)\nat org.eclipse.jdt.internal.core.hierarchy.HierarchyResolver.accept\n(HierarchyResolver.java:153)\nat org.eclipse.jdt.internal.compiler.lookup.LookupEnvironment.askForType\n(LookupEnvironment.java:131)\nat org.eclipse.jdt.internal.compiler.lookup.PackageBinding.getTypeOrPackage\n(PackageBinding.java:178)\nat org.eclipse.jdt.internal.compiler.lookup.Scope.getTypeOrPackage\n(Scope.java:2427)\nat org.eclipse.jdt.internal.compiler.lookup.Scope.getType(Scope.java:2166)\nat org.eclipse.jdt.internal.compiler.ast.SingleTypeReference.getTypeBinding\n(SingleTypeReference.java:39)\nat org.eclipse.jdt.internal.compiler.ast.TypeReference.resolveType\n(TypeReference.java:141)\nat org.eclipse.jdt.internal.compiler.ast.TypeReference.resolveTypeArgument\n(TypeReference.java:158)\nat \norg.eclipse.jdt.internal.compiler.ast.ParameterizedSingleTypeReference.internal\nResolveType(ParameterizedSingleTypeReference.java:136)\nat \norg.eclipse.jdt.internal.compiler.ast.ParameterizedSingleTypeReference.resolveT\nype(ParameterizedSingleTypeReference.java:223)\nat org.eclipse.jdt.internal.compiler.ast.TypeReference.resolveSuperType\n(TypeReference.java:104)\nat org.eclipse.jdt.internal.compiler.lookup.ClassScope.findSupertype\n(ClassScope.java:1097)\nat org.eclipse.jdt.internal.compiler.lookup.ClassScope.connectSuperclass\n(ClassScope.java:757)\nat org.eclipse.jdt.internal.compiler.lookup.ClassScope.connectTypeHierarchy\n(ClassScope.java:937)\nat \norg.eclipse.jdt.internal.compiler.lookup.CompilationUnitScope.connectTypeHierar\nchy(CompilationUnitScope.java:258)\nat \norg.eclipse.jdt.internal.compiler.lookup.LookupEnvironment.completeTypeBindings\n(LookupEnvironment.java:251)\nat org.eclipse.jdt.internal.core.hierarchy.HierarchyResolver.accept\n(HierarchyResolver.java:153)\nat org.eclipse.jdt.internal.compiler.lookup.LookupEnvironment.askForType\n(LookupEnvironment.java:131)\nat org.eclipse.jdt.internal.compiler.lookup.PackageBinding.getTypeOrPackage\n(PackageBinding.java:178)\nat org.eclipse.jdt.internal.compiler.lookup.Scope.getTypeOrPackage\n(Scope.java:2427)\nat org.eclipse.jdt.internal.compiler.lookup.Scope.getType(Scope.java:2166)\nat \norg.eclipse.jdt.internal.compiler.ast.ParameterizedSingleTypeReference.internal\nResolveType(ParameterizedSingleTypeReference.java:98)\nat \norg.eclipse.jdt.internal.compiler.ast.ParameterizedSingleTypeReference.resolveT\nype(ParameterizedSingleTypeReference.java:223)\nat org.eclipse.jdt.internal.compiler.ast.TypeReference.resolveSuperType\n(TypeReference.java:104)\nat org.eclipse.jdt.internal.compiler.lookup.ClassScope.findSupertype\n(ClassScope.java:1097)\nat org.eclipse.jdt.internal.compiler.lookup.ClassScope.connectSuperclass\n(ClassScope.java:757)\nat org.eclipse.jdt.internal.compiler.lookup.ClassScope.connectTypeHierarchy\n(ClassScope.java:937)\nat \norg.eclipse.jdt.internal.compiler.lookup.CompilationUnitScope.connectTypeHierar\nchy(CompilationUnitScope.java:258)\nat \norg.eclipse.jdt.internal.compiler.lookup.LookupEnvironment.completeTypeBindings\n(LookupEnvironment.java:251)\nat org.eclipse.jdt.internal.core.hierarchy.HierarchyResolver.resolve\n(HierarchyResolver.java:653)\nat \norg.eclipse.jdt.internal.core.hierarchy.IndexBasedHierarchyBuilder.buildForProj\nect(IndexBasedHierarchyBuilder.java:197)\nat \norg.eclipse.jdt.internal.core.hierarchy.IndexBasedHierarchyBuilder.buildFromPot\nentialSubtypes(IndexBasedHierarchyBuilder.java:304)\nat org.eclipse.jdt.internal.core.hierarchy.IndexBasedHierarchyBuilder.build\n(IndexBasedHierarchyBuilder.java:130)\nat org.eclipse.jdt.internal.core.hierarchy.TypeHierarchy.compute\n(TypeHierarchy.java:320)\nat org.eclipse.jdt.internal.core.hierarchy.TypeHierarchy.refresh\n(TypeHierarchy.java:1255)\nat org.eclipse.jdt.internal.core.CreateTypeHierarchyOperation.executeOperation\n(CreateTypeHierarchyOperation.java:90)\nat org.eclipse.jdt.internal.core.JavaModelOperation.run\n(JavaModelOperation.java:718)\nat org.eclipse.jdt.internal.core.JavaModelOperation.runOperation\n(JavaModelOperation.java:777)\nat org.eclipse.jdt.internal.core.SourceType.newTypeHierarchy\n(SourceType.java:716)\nat \norg.eclipse.jdt.internal.ui.typehierarchy.TypeHierarchyLifeCycle.createTypeHier\narchy(TypeHierarchyLifeCycle.java:118)\nat \norg.eclipse.jdt.internal.ui.typehierarchy.TypeHierarchyLifeCycle.doHierarchyRef\nresh(TypeHierarchyLifeCycle.java:157)\nat org.eclipse.jdt.internal.ui.typehierarchy.TypeHierarchyLifeCycle$1.run\n(TypeHierarchyLifeCycle.java:98)\nat org.eclipse.jface.operation.ModalContext$ModalContextThread.run\n(ModalContext.java:113)\n\nSession data:\n\neclipse.buildId=I20050811-1530\njava.version=1.5.0_04\njava.vendor=Sun Microsystems Inc.\nBootLoader constants: OS=win32, ARCH=x86, WS=win32, NL=en_US\nCommand-line arguments:  -os win32 -ws win32 -arch x86",,,,
103227,, [1.5][compiler] VerifyError in case of a parametrized anonymous class inside a static inner class  ,3.1.1,philippe_mulet@fr.ibm.com,blocker,P3,37079.75556,37084.35394,4.59837963,222,"The following code doesn't pass verifier because\nthe method String get(int) of the anonymous class\nbecause eclipse compiler generate as last byte-code a\nireturn and not a areturn.\n\nprogram :\npackage fr.umlv.tatoo.test;\n\nimport java.util.AbstractList;\nimport java.util.List;\n\npublic class BogusVerifier {\n\n  private static class Entry {\n    public void doIt(final List<? extends String> args) {\n      List<String> list=new AbstractList<String>() {\n          @Override public int size() {\n            return 0;\n          }\n          @Override public String get(int i) {\n            return args.get(i);\n          }\n        };\n    }\n  }\n\n}\n\njavap output:\n\npublic java.lang.String get(int);\n  Code:\n   0:\taload_0\n   1:\tgetfield\t#15; //Field val$args:Ljava/util/List;\n   4:\tiload_1\n   5:\tinvokeinterface\t#31,  2; //InterfaceMethod\njava/util/List.get:(I)Ljava/lang/Object;\n   10:\tcheckcast\t#33; //class java/lang/String\n   13:\tireturn // <-------------- OUPS\n\nRÃ©mi Forax",,,,
104492,, [AST]java.lang.ClassCastException: org.eclipse.jdt.core.dom.PrimitiveType  ,3.1.1,Olivier_Thomann@ca.ibm.com,major,P3,37091.42153,37091.66476,0.243229167,138,"When working with for loop for primitive arrays, java code editor always throws \n(in error log):\n java.lang.ClassCastException: org.eclipse.jdt.core.dom.PrimitiveType\n\tat \norg.eclipse.jdt.core.dom.ASTConverter.setTypeForSingleVariableDeclaration\n(ASTConverter.java:4920)\n\tat \norg.eclipse.jdt.core.dom.ASTConverter.convertToSingleVariableDeclaration\n(ASTConverter.java:2774)\n\tat org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1629)\n\tat org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2201)\n\tat org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:502)\n\tat org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations\n(ASTConverter.java:178)\n\tat org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2486)\n\tat org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1162)\n\tat org.eclipse.jdt.core.dom.CompilationUnitResolver.convert\n(CompilationUnitResolver.java:251)\n\tat org.eclipse.jdt.core.dom.ASTParser.internalCreateAST\n(ASTParser.java:800)\n\tat org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:588)\n\tat org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run\n(ASTProvider.java:566)\n\tat org.eclipse.core.internal.runtime.InternalPlatform.run\n(InternalPlatform.java:1044)\n\tat org.eclipse.core.runtime.Platform.run(Platform.java:783)\n\tat org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST\n(ASTProvider.java:563)\n\tat org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST\n(ASTProvider.java:493)\n\tat \norg.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartList\nenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:165)\n\tat \norg.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$3.run\n(SelectionListenerWithASTManager.java:142)\n\tat org.eclipse.core.internal.jobs.Worker.run(Worker.java:76)\n\nWith this error JDT cannot check breakpoint too.",,,,
105255,, [BIDI] need to add $nl$  to icon paths for reversed icons  ,3.1.1,Darin_Wright@ca.ibm.com,normal,P3,37097.92014,37107.45108,9.5309375,128,"Target for 3.1.1 release (NL release).\n\nIn Eclipse 3.1, icons are being supplied for BiDi locales that will appear as \nif the icon has been reversed.  For all plugins that supply icons, some code \nchanges are required to support this that do not appear to be present when \nrunning Eclipse in a BiDi locale (get BiDi fragments then run Eclipse with \nprogram argument -nl ar_EG).  The following 2 items need to be checked:\n1. Paths to icons/images that can appear flipped must be prefixed with $nl$/ \n(e.g. $nl$/ICON_PATH) - this includes paths to icons and images in plugin.xml.\n2. Must use Platform.find(Bundle, Path) to create the URL that is used to \ncreate the image descriptor.\nSee Tod's Eclipse blog entry for more details on the code changes required. \nhttp://todcreaseyeclipse.blogspot.com/\n\nNOTE: Only icons that have the possibility of being flipped need to have this \nprefix added - you can leave the paths of other icons as they are for 3.1.1 if \nyou want to keep changes to a minimum.  You can get the BiDi nl fragments from \nCam-Thu Le so that you can see which of your icons have a reversed counterpart \nin BiDi locales.  \n\nThe following plugins of this component have been identified as requiring this \ncheck:\n*org.eclipse.jdt.debug.ui \n\nQuestions about this issue can be directed to Karice McIntyre or Tod Creasey.",,,,
101677,, [call hierarchy] Cannot cancel tree expansion jobs except in jobs view  ,3.1.1,markus_keller@ch.ibm.com,normal,P3,37065.53681,37113.50954,47.97273148,230,3.1 RC4\n\nSee bug 101625: Had to disable cancelling due to NPEs.,,,,
99995,," [code assist] Code Assist for parameterized anonymous types: overridden methods for raw, not parameterized  ",3.1.1,tobias_widmer@ch.ibm.com,normal,P3,37055.50278,37071.23714,15.73436343,80,I20050610-1757 (3.1RC2)\n\npublic class Anon {\n\tvoid test() {\n\t\tnew java.util.ArrayList<Integer>()\n\t}\n}\n\nInvoke content assist after 'ArrayList<Integer>(' and choose the anonymous.\n-> The methods to be overridden are constructed for a raw ArrayList (they have\ntheir 'E's replaced by 'Object' instead of 'Integer').,,,,
106814,, [code manipulation] 'Add import' leaves '.' before type name  ,3.1.1,martin_aeschlimann@ch.ibm.com,normal,P2,37114.08056,37120.26892,6.188368056,84,"Build id: I20050627-1435\nDoes not happen always, seps are like this:\n1. Type a class name within method body and hit Ctrl + Space to resolve class -\nthis adds fully qualified class since auto imports are disabled. \n2. Type '.' and access a field. Code looks like this:\n  com.some.util.TypeDocs.SALES_MEMO\n3. Hit Ctrl+Shif+M to add import. Import is added, but the dot before class name\nremains and must be removed  manually. Code is like this: \n  .TypeDocs.SALES_MEMO",,,,
104664,, [compiler] repeat mode is broken in the batch compiler  ,3.1.1,Olivier_Thomann@ca.ibm.com,normal,P3,37092.43611,37096.46995,4.033842593,284,Using -repeat 5 with the batch compiler is broken when jar files are used on the\nclasspath.\n\njava.lang.IllegalStateException: zip file closed\n   at java.util.zip.ZipFile.ensureOpen(ZipFile.java:519)\n   at java.util.zip.ZipFile.entries(ZipFile.java:407)\n   at\norg.eclipse.jdt.internal.compiler.batch.ClasspathJar.isPackage(ClasspathJar.java:59)\n   at\norg.eclipse.jdt.internal.compiler.batch.ClasspathJar.findClass(ClasspathJar.java:40)\n   at\norg.eclipse.jdt.internal.compiler.batch.FileSystem.findClass(FileSystem.java:147)\n   at\norg.eclipse.jdt.internal.compiler.batch.FileSystem.findType(FileSystem.java:171)\n   at\norg.eclipse.jdt.internal.compiler.lookup.LookupEnvironment.createPackage(LookupEnvironment.java:517)\n   at\norg.eclipse.jdt.internal.compiler.lookup.CompilationUnitScope.buildTypeBindings(CompilationUnitScope.java:83)\n   at\norg.eclipse.jdt.internal.compiler.lookup.LookupEnvironment.buildTypeBindings(LookupEnvironment.java:144)\n   at org.eclipse.jdt.internal.compiler.Compiler.beginToCompile(Compiler.java:292)\n   at org.eclipse.jdt.internal.compiler.Compiler.compile(Compiler.java:315)\n   at\norg.eclipse.jdt.internal.compiler.batch.Main.performCompilation(Main.java:2692)\n   at\norg.eclipse.jdt.internal.compiler.batch.Main.compile(Main.java:1151)[repetition 2/5]\n \n   at org.eclipse.jdt.internal.compiler.batch.Main.compile(Main.java:1048)\n   at org.eclipse.jdt.internal.compiler.batch.Main.compile(Main.java:1040)\n   at org.eclipse.jdt.core.tools.compiler.Compile.main(Compile.java:19)\n\nThe first compilation resets the internal zip file of the ClasspathJar object.,,,,
109963,, [dom] Two VariableDeclarationStatements in switch  ,3.1.1,Olivier_Thomann@ca.ibm.com,normal,P3,37153.17917,37161.49119,8.312025463,231,"Version: 3.1.0\nBuild id: I20050919-0010\n\nThe ast for:\n\nswitch (y) {\ncase 1:\n\tint i,j;\n}\n\nis:\n\nSwitchStatement [71, 41]\n|->SwitchCase [87, 7]\n|->VariableDeclarationStatement [99, 8]\n| |->VariableDeclarationFragment [103, 1] (i)\n|->VariableDeclarationStatement [99, 8]\n  |->VariableDeclarationFragment [105, 1] (j)\n\nBut I guess it should be one VariableDeclarationStatement containing two\nfragments, one for i and one for j.",,,,
101247,101283, [formatter] Fails to format some labelled statements  ,3.1.1,Olivier_Thomann@ca.ibm.com,normal,P3,37063.42153,37070.38148,6.959953704,140,"Using N0622, the code formatter fails to format the following code.\n\npublic class X {\n  public static void main(String[] args) {\n    if(true) throw new RuntimeException(""X"");\n    X: System.out.println(""X"");\n  }\n}",,,,
101885,, [mode] sort operation doesn't set the RELATIVE_ORDER for enum constants  ,3.1.1,Olivier_Thomann@ca.ibm.com,normal,P3,37068.51944,37070.38917,1.869722222,40,The RELATIVE_ORDER property is not set for enum constants.\nThis can potentially leads to NPE.,,,,
108105,, [open type] Do less type history consistency checks  ,3.1.1,dirk_baeumer@ch.ibm.com,normal,P3,37128.36667,37133.24036,4.87369213,129,3.1.\n\nThe type history consistency check is done every time the dialog opens. However\nthis check is only needed when types have been removed from the system. So the\nhistory could listen on delta changes an only perform the check if necessary.,,,,
108840,, [open type] open type shows duplicate entry after type visibility change  ,3.1.1,dirk_baeumer@ch.ibm.com,normal,P3,37139.47986,37140.21741,0.737546296,4,"3.1.1 maintenance build from Sept 1, 05\n\n- have a type ""public class Foo""\n- open Foo using open type -> persisted in the open type history\n- change visibility of Foo to package private\n- open type\n  -> note that the public type is still available from the history\n  -> note that also the package private version can be opened via open type\n  -> both types then show up side by side in open type\n\nExpected: the public version gets pruned when the visibility changes.",,,,
102193,, [Organize Imports] generic method problem  ,3.1.1,martin_aeschlimann@ch.ibm.com,critical,P3,37070.65,37083.50128,12.85128472,128,"In Eclipse 3.1, if my code has the following line:\n  Collections.<MyType>emptySet();\n\nand I issue the Organize Imports command, MyType will be removed from the\nimports unless it is used elsewhere in that class.",,,,
97027,, [override marker] Incorrect override method marker  ,3.1.1,martin_aeschlimann@ch.ibm.com,normal,P3,37037.53889,37047.4909,9.952013889,465,"In this case BB.test does not override AA.test, but its tagged in the editor \nthat it does.\n\nclass AA<T> {\n\tpublic AA<Object> test() { return null; }\n}\nclass BB extends AA<CC> {\n\tpublic <T> BB test() { return null; }\n}\nclass CC {}",,,,
103686,, [quick fix] Convert to enhanced for loop does not convert loop with Enumeration  ,3.1.1,tobias_widmer@ch.ibm.com,normal,P3,37084.56181,37117.19071,32.62890046,225,"3.1\n\nI wanted to convert this for loop to an enhanced for loop, but the quick fix did\nnot appear:\n\nprivate synchronized Vector<TestListener> cloneListeners() {\n\treturn (Vector<TestListener>)fListeners.clone();\n}\n\npublic void endTest(Test test) {\n\tfor (Enumeration<TestListener> e= cloneListeners().elements();\n\t\t\te.hasMoreElements(); ) {\n\t\tTestListener nextElement = e.nextElement();\n\t\tnextElement.endTest(test);\n\t}\n}",,,,
106403,106202, PublicScanner returns EOF late  ,3.1.1,Olivier_Thomann@ca.ibm.com,normal,P3,37110.67361,37113.49488,2.821273148,306,"PROBLEM\n\nA whitespace-tokenizing PublicScanner returns a whitespace token when the\nwhitespace starts one position after the end position specified by resetTo(). It\nshould return EOF. Below is some test code that tickles the bug, along with its\noutput. I ran it inside a HelloWorld plug-in. I also give a workaround for\nclients and a possible, untested fix.\n\nCODE\n\npublic void testScanner() throws InvalidInputException\n{\n   IScanner s = ToolFactory.createScanner (true, true, true, ""1.5"", ""1.5"");\n   System.err.println(""IScanner is "" + s.getClass());\n   char[] source = {';', ' '};\n   s.setSource (source);\n   s.resetTo (0, 0);\n   s.getNextToken ();\n   System.err.println(""token is ;? ""\n      + "";"".equals (new String (s.getRawTokenSource ())));\n   int t = s.getNextToken ();\n   System.err.println(""token is EOF? ""\n      + (ITerminalSymbols.TokenNameEOF == t));\n}\n\nOUTPUT\n\nIScanner is class org.eclipse.jdt.internal.core.util.PublicScanner\ntoken is ;? true\ntoken is EOF? false\n\nWORKAROUND\n\nClients need to check for EOF and tokens whose start position is after end. For\nexample:\n\n   int token;\n   IScanner scanner =\n      ToolFactory.createScanner (true, true, true, ""1.5"", ""1.5"");\n   scanner.setSource (source);\n   scanner.resetTo (start, end);\n   token = scanner.getNextToken ();\n   while (token != ITerminalSymbols.TokenNameEOF\n          && scanner.getCurrentTokenStartPosition () <= end))\n   {\n      // ...\n      token = scanner.getNextToken ();\n   }\n\nPOSSIBLE, UNTRIED FIX\n\nIn PublicScanner.getNextToken(), just bofore consuming whitespace, check for EOF.\n\n   ...\n   int whiteStart = 0;\n   try {\n      // FIX?\n      if (this.currentPosition >= this.eofPosition) {\n         return TokenNameEOF;\n      }\n      // END FIX?\n      while (true) { //loop for jumping over comments\n         this.withoutUnicodePtr = 0;\n         ...",,,,
104065,, [quick fix] No Quick Fixes for marker with IMarker.LINE_NUMBER and no IMarker.CHAR_START and IMarker.CHAR_END  ,3.1.1,martin_aeschlimann@ch.ibm.com,normal,P3,37086.60417,37098.37904,11.77487269,4,"I'm creating (problem) markers for a java file and I only have a line number\navailable when I create the marker. I add the IMarker.LINE_NUMBER attribute to\nthe marker attributes, but do not specify a CHAR_START or CHAR_END. The marker\nshows up in the file, but there are no Quick Fixes available for it (using\nCtrl+1 or right click on the marker). When I click on the marker in the problems\nview, however, I get the quick fixes that are possible. (This used to work in\n3.0, doesnt now in 3.1)\n\nI traced through the code and found that the markers with a line number get\ntheir end and start range set to be the same in:\nAbstractMarkerAnnotationModel.createPositionFromMarker(IMarker marker).  Because\nthe start and end are both -1 coming into the method, end = start. \n\nIn JavaCorrectionAssistant.collectQuickFixableAnnotations(), there is a check to\nsee if the Position for the offset is within the range -- its a call to\nJavaCorrectionAssistant.isInside(). isInside has the following body:\n\tprivate static boolean isInside(int offset, int start, int end) {\n\t\treturn offset >= start && offset < end;\n\t}\n\nBUT, because the start and end are set to be the same, its NEVER inside. The net\neffect: any markers with a position set via LINE_NUMBER will not get a quick fix.",,,,
101938,, [refactoring] extact method: missing call to extracted method  ,3.1.1,dirk_baeumer@ch.ibm.com,normal,P3,37068.70764,37097.5149,28.80725694,35,"3.1RC4\npublic class AA {\n\tboolean foo(boolean b, Object x, List l){\n\t\tif (b){\n\t\t\t/*[*/\n\t\t\tif (x instanceof Integer)\n\t\t\t\treturn false;\n\t\t\treturn true;\n\t\t\t/*]*/\n\t\t} else {\n\t\t\tfor (Iterator iter = l.iterator(); iter.hasNext();) {\n\t\t\t\tObject next= iter.next();\n\t\t\t\tif (next instanceof Integer)\n\t\t\t\t\treturn false;\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t}\n}\n\n'Replace duplicate fragments'\nIn the loop, the call to the new method is missing",,,,
104030,, [refactoring] extract interface:NPE in SuperTypeConstraintsModel  ,3.1.1,tobias_widmer@ch.ibm.com,normal,P3,37086.49028,37112.38536,25.89508102,20,"3.1\nextract the attached source\nopen interace Node\n'Extract Interface', select all methods\n\njava.lang.NullPointerException\nat\norg.eclipse.jdt.internal.corext.refactoring.structure.constraints.SuperTypeConstraintsModel.createTypeVariable(SuperTypeConstraintsModel.java:478)\nat\norg.eclipse.jdt.internal.corext.refactoring.structure.constraints.SuperTypeConstraintsCreator.endVisit(SuperTypeConstraintsCreator.java:685)\nat\norg.eclipse.jdt.internal.corext.dom.HierarchicalASTVisitor.endVisit(HierarchicalASTVisitor.java:707)\nat org.eclipse.jdt.core.dom.SimpleType.accept0(SimpleType.java:138)\nat org.eclipse.jdt.core.dom.ASTNode.accept(ASTNode.java:2450)\nat org.eclipse.jdt.core.dom.ASTNode.acceptChild(ASTNode.java:2497)\nat org.eclipse.jdt.core.dom.MethodDeclaration.accept0(MethodDeclaration.java:495)\nat org.eclipse.jdt.core.dom.ASTNode.accept(ASTNode.java:2450)\nat org.eclipse.jdt.core.dom.ASTNode.acceptChildren(ASTNode.java:2520)\nat org.eclipse.jdt.core.dom.TypeDeclaration.accept0(TypeDeclaration.java:483)\nat org.eclipse.jdt.core.dom.ASTNode.accept(ASTNode.java:2450)\nat org.eclipse.jdt.core.dom.ASTNode.acceptChildren(ASTNode.java:2520)\nat org.eclipse.jdt.core.dom.CompilationUnit.accept0(CompilationUnit.java:299)\nat org.eclipse.jdt.core.dom.ASTNode.accept(ASTNode.java:2450)\nat\norg.eclipse.jdt.internal.corext.refactoring.structure.constraints.SuperTypeRefactoringProcessor.performFirstPass(SuperTypeRefactoringProcessor.java:306)\nat\norg.eclipse.jdt.internal.corext.refactoring.structure.constraints.SuperTypeRefactoringProcessor$3.acceptAST(SuperTypeRefactoringProcessor.java:656)\nat\norg.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:691)\nat\norg.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:455)\nat org.eclipse.jdt.core.dom.ASTParser.createASTs(ASTParser.java:664)\nat\norg.eclipse.jdt.internal.corext.refactoring.structure.constraints.SuperTypeRefactoringProcessor.solveSuperTypeConstraints(SuperTypeRefactoringProcessor.java:650)\nat\norg.eclipse.jdt.internal.corext.refactoring.structure.ExtractInterfaceProcessor.access$2(ExtractInterfaceProcessor.java:1)\nat\norg.eclipse.jdt.internal.corext.refactoring.structure.ExtractInterfaceProcessor$2.acceptAST(ExtractInterfaceProcessor.java:1106)\nat\norg.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:691)\nat\norg.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:455)\nat org.eclipse.jdt.core.dom.ASTParser.createASTs(ASTParser.java:664)\nat\norg.eclipse.jdt.internal.corext.refactoring.structure.ExtractInterfaceProcessor.rewriteTypeOccurrences(ExtractInterfaceProcessor.java:1088)\nat\norg.eclipse.jdt.internal.corext.refactoring.structure.ExtractInterfaceProcessor.createChangeManager(ExtractInterfaceProcessor.java:359)\nat\norg.eclipse.jdt.internal.corext.refactoring.structure.ExtractInterfaceProcessor.checkFinalConditions(ExtractInterfaceProcessor.java:224)\nat\norg.eclipse.ltk.core.refactoring.participants.ProcessorBasedRefactoring.checkFinalConditions(ProcessorBasedRefactoring.java:169)\nat\norg.eclipse.ltk.core.refactoring.CheckConditionsOperation.run(CheckConditionsOperation.java:84)\nat\norg.eclipse.ltk.core.refactoring.CreateChangeOperation.run(CreateChangeOperation.java:114)\nat org.eclipse.core.internal.resources.Workspace.run(Workspace.java:1719)\nat\norg.eclipse.ltk.internal.ui.refactoring.WorkbenchRunnableAdapter.run(WorkbenchRunnableAdapter.java:86)\nat\norg.eclipse.jface.operation.ModalContext$ModalContextThread.run(ModalContext.java:113)",,,,
108115,, [refactoring] Extract Local Variable and Ex. Constant don't find matching invocations of generic methods  ,3.1.1,markus_keller@ch.ibm.com,normal,P3,37128.43264,37132.38936,3.956724537,54,"M20050824-1200\n\nSee JDT/Core bug 104293. For that specific instance of the problem, there's an\neasy workaround in JdtASTMatcher that we should submit for 3.1.1.",,,,
105829,, [refactoring] infer type arguments: StackOverflowError  ,3.1.1,markus_keller@ch.ibm.com,normal,P3,37104.54375,37128.46598,23.9222338,40,3.1\npublic class A {\n\tvoid foo() {\n\t\tVector v1= new Vector(),\n\t\tVector v2= new Vector(),\n\t\tv2.add(v1),\n\t\tv1.add(v2),\n\t}\n}\n\nCaused by: java.lang.StackOverflowError\nat\norg.eclipse.jdt.internal.corext.refactoring.generics.ParametricStructureComputer.updateStructureOfIthParamFrom(ParametricStructureComputer.java:297)\nat\norg.eclipse.jdt.internal.corext.refactoring.generics.ParametricStructureComputer.updateStructureOfType(ParametricStructureComputer.java:400)\nat\norg.eclipse.jdt.internal.corext.refactoring.generics.ParametricStructureComputer.updateStructureOfIthParamFrom(ParametricStructureComputer.java:298)\nat\norg.eclipse.jdt.internal.corext.refactoring.generics.ParametricStructureComputer.updateStructureOfType(ParametricStructureComputer.java:400)\nat\norg.eclipse.jdt.internal.corext.refactoring.generics.ParametricStructureComputer.updateStructureOfIthParamFrom(ParametricStructureComputer.java:298)\nat\norg.eclipse.jdt.internal.corext.refactoring.generics.ParametricStructureComputer.updateStructureOfType(ParametricStructureComputer.java:400)\nat\norg.eclipse.jdt.internal.corext.refactoring.generics.ParametricStructureComputer.updateStructureOfIthParamFrom(ParametricStructureComputer.java:298)\nat\norg.eclipse.jdt.internal.corext.refactoring.generics.ParametricStructureComputer.updateStructureOfType(ParametricStructureComputer.java:400)\n...
102534,, [refactoring] Inline method: Null pointer exception  ,3.1.1,dirk_baeumer@ch.ibm.com,normal,P3,37072.68889,37097.48082,24.79193287,0, ,,,,
101863,, [refactoring] Move member type to new file: assertion failure  ,3.1.1,tobias_widmer@ch.ibm.com,normal,P3,37068.39097,37112.50218,44.1112037,4,3.1-RC4\n\n- have the CU I will attach\n- try to Refactor>Move Nested Type to New File on nested type 'Domain<T>'\n\n-> AFE:\n\nCaused by: org.eclipse.jdt.internal.corext.Assert$AssertionFailedException: null\nargument,\n\tat org.eclipse.jdt.internal.corext.Assert.isNotNull(Assert.java:108)\n\tat org.eclipse.jdt.internal.corext.Assert.isNotNull(Assert.java:86)\n\tat\norg.eclipse.jdt.internal.corext.refactoring.structure.MoveInnerToTopRefactoring.findTypeDeclaration(MoveInnerToTopRefactoring.java:406)\n\tat\norg.eclipse.jdt.internal.corext.refactoring.structure.MoveInnerToTopRefactoring.createNewSource(MoveInnerToTopRefactoring.java:1018)\n\tat\norg.eclipse.jdt.internal.corext.refactoring.structure.MoveInnerToTopRefactoring.createChangeManager(MoveInnerToTopRefactoring.java:839)\n\tat\norg.eclipse.jdt.internal.corext.refactoring.structure.MoveInnerToTopRefactoring.checkFinalConditions(MoveInnerToTopRefactoring.java:743)\n\tat\norg.eclipse.ltk.core.refactoring.CheckConditionsOperation.run(CheckConditionsOperation.java:84)\n\tat\norg.eclipse.ltk.core.refactoring.CreateChangeOperation.run(CreateChangeOperation.java:114)\n\tat org.eclipse.core.internal.resources.Workspace.run(Workspace.java:1719)\n\tat\norg.eclipse.ltk.internal.ui.refactoring.WorkbenchRunnableAdapter.run(WorkbenchRunnableAdapter.java:86)\n\tat\norg.eclipse.jface.operation.ModalContext$ModalContextThread.run(ModalContext.java:113),,,
106728,, [type hierarchy] Incorrect 'overriding method' in type hierarchy  ,3.1.1,martin_aeschlimann@ch.ibm.com,normal,P3,37113.23264,37154.50409,41.27144676,20,"3.1, 1.4 compiler compliance\n\nWith the following two CUs the Type Hierarchy shows the incorrect overriding\nmethod when enabling 'Lock View and Show Members' and the Quick Type Hierarchy\nwill navigate to the incorrect overriding method for Object bar(String, String).\n\ninterface IFoo {\n\tObject bar(String s2, String s);\n\tString bar(String s2, Object o);\n}\n\nclass Foo implements IFoo {\n\tpublic Object bar(String s2, String s) {\n\t\treturn null;\n\t}\n\tpublic String bar(String s2, Object o) {\n\t\treturn null;\n\t}\n}",,,,
108258,, [typing] Toggle Comment on folded Javadoc fails  ,3.1.1,eclipse@tom.eicher.name,major,P2,37131.30833,37138.47197,7.163634259,191,Eclipse is trying to compile a javadoc comment as java-sourcecode if it gets\nuncommented.\n\nExample (linenumbers added):\n1    /**\n2     * This method gets called when a bound property is changed.\n3     * \n4     * @param evt A PropertyChangeEvent object describing the event source and\nthe property that has\n5     *            changed.\n6     */\n7    public void propertyChange(PropertyChangeEvent evt)\n8    {\n9    }\n\n1. Mark line 2-6 and comment with Strg-/\n2. Save the file\n3. Mark line 2-6 and uncomment with Strg-/\n4. Save the file\n=> The javadoc comment is handled as sourcecode and compile errors are displayed\nfor the javadoc section,,,,
106964,, [1.5][search] AIOBE in MethodLocator.matchOverriddenMethod  ,3.1.1,frederic_fusier@fr.ibm.com,normal,P3,37116.46667,37118.43301,1.966342593,516,"I'm using maintenance build Version: 3.1.1 Build id: M20050811-0400, during \nrefactoring (rename) of method in interface, I have some times such errors in \nthe log, and refactoring fails:\n\njava.lang.reflect.InvocationTargetException\n\tat org.eclipse.jface.operation.ModalContext.run(ModalContext.java:327)\n\tat org.eclipse.ltk.internal.ui.refactoring.RefactoringWizardDialog2.\nrun(RefactoringWizardDialog2.java:293)\n\tat org.eclipse.ltk.ui.refactoring.RefactoringWizard.\ncreateChange(RefactoringWizard.java:573)\n\tat org.eclipse.ltk.ui.refactoring.RefactoringWizard.\ncomputeUserInputSuccessorPage(RefactoringWizard.java:416)\n\tat org.eclipse.ltk.ui.refactoring.UserInputWizardPage.\ncomputeSuccessorPage(UserInputWizardPage.java:74)\n\tat org.eclipse.ltk.ui.refactoring.UserInputWizardPage.\ngetNextPage(UserInputWizardPage.java:114)\n\tat org.eclipse.ltk.internal.ui.refactoring.RefactoringWizardDialog2.\npreviewPressed(RefactoringWizardDialog2.java:447)\n\tat org.eclipse.ltk.internal.ui.refactoring.RefactoringWizardDialog2.\naccess$3(RefactoringWizardDialog2.java:445)\n\tat org.eclipse.ltk.internal.ui.refactoring.RefactoringWizardDialog2$1.\nwidgetSelected(RefactoringWizardDialog2.java:584)\n\tat org.eclipse.swt.widgets.TypedListener.handleEvent(TypedListener.java:\n90)\n\tat org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:66)\n\tat org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:843)\n\tat org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:3080)\n\tat org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:2713)\n\tat org.eclipse.jface.window.Window.runEventLoop(Window.java:809)\n\tat org.eclipse.jface.window.Window.open(Window.java:787)\n\tat org.eclipse.ltk.ui.refactoring.RefactoringWizardOpenOperation$1.\nrun(RefactoringWizardOpenOperation.java:125)\n\tat org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:69)\n\tat org.eclipse.ltk.ui.refactoring.RefactoringWizardOpenOperation.\nrun(RefactoringWizardOpenOperation.java:138)\n\tat org.eclipse.jdt.internal.ui.refactoring.actions.RefactoringStarter.\nactivate(RefactoringStarter.java:40)\n\tat org.eclipse.jdt.internal.ui.refactoring.UserInterfaceStarter.\nactivate(UserInterfaceStarter.java:56)\n\tat org.eclipse.jdt.internal.ui.refactoring.reorg.\nRenameUserInterfaceStarter.activate(RenameUserInterfaceStarter.java:113)\n\tat org.eclipse.jdt.internal.ui.refactoring.reorg.\nRenameMethodUserInterfaceStarter.activate(RenameMethodUserInterfaceStarter.java:\n68)\n\tat org.eclipse.jdt.ui.refactoring.RenameSupport.openDialog(RenameSupport.\njava:114)\n\tat org.eclipse.jdt.internal.corext.refactoring.\nRefactoringExecutionStarter.startRenameRefactoring(RefactoringExecutionStarter.\njava:327)\n\tat org.eclipse.jdt.internal.ui.refactoring.actions.\nRenameJavaElementAction.run(RenameJavaElementAction.java:171)\n\tat org.eclipse.jdt.internal.ui.refactoring.actions.\nRenameJavaElementAction.run(RenameJavaElementAction.java:131)\n\tat org.eclipse.jdt.ui.actions.RenameAction.run(RenameAction.java:117)\n\tat org.eclipse.jdt.ui.actions.SelectionDispatchAction.\ndispatchRun(SelectionDispatchAction.java:226)\n\tat org.eclipse.jdt.ui.actions.SelectionDispatchAction.\nrun(SelectionDispatchAction.java:198)\n\tat org.eclipse.jface.action.Action.runWithEvent(Action.java:996)\n\tat org.eclipse.jface.action.ActionContributionItem.\nhandleWidgetSelection(ActionContributionItem.java:538)\n\tat org.eclipse.jface.action.ActionContributionItem.\naccess$2(ActionContributionItem.java:488)\n\tat org.eclipse.jface.action.ActionContributionItem$5.\nhandleEvent(ActionContributionItem.java:400)\n\tat org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:66)\n\tat org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:843)\n\tat org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:3080)\n\tat org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:2713)\n\tat org.eclipse.ui.internal.Workbench.runEventLoop(Workbench.java:1699)\n\tat org.eclipse.ui.internal.Workbench.runUI(Workbench.java:1663)\n\tat org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:\n367)\n\tat org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:143)\n\tat org.eclipse.ui.internal.ide.IDEApplication.run(IDEApplication.java:103)\n\tat org.eclipse.core.internal.runtime.PlatformActivator$1.\nrun(PlatformActivator.java:226)\n\tat org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.\njava:376)\n\tat org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.\njava:163)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.\njava:39)\n\tat sun.reflect.DelegatingMethodAccessorImpl.\ninvoke(DelegatingMethodAccessorImpl.java:25)\n\tat java.lang.reflect.Method.invoke(Method.java:585)\n\tat org.eclipse.core.launcher.Main.invokeFramework(Main.java:334)\n\tat org.eclipse.core.launcher.Main.basicRun(Main.java:278)\n\tat org.eclipse.core.launcher.Main.run(Main.java:973)\n\tat org.eclipse.core.launcher.Main.main(Main.java:948)\nCaused by: java.lang.ArrayIndexOutOfBoundsException: 1\n\tat org.eclipse.jdt.internal.core.search.matching.MethodLocator.\nmatchOverriddenMethod(MethodLocator.java:290)\n\tat org.eclipse.jdt.internal.core.search.matching.MethodLocator.\nnewDeclarationMatch(MethodLocator.java:471)\n\tat org.eclipse.jdt.internal.core.search.matching.MatchLocator.\nreportMatching(MatchLocator.java:1820)\n\tat org.eclipse.jdt.internal.core.search.matching.MatchLocator.\nreportMatching(MatchLocator.java:2209)\n\tat org.eclipse.jdt.internal.core.search.matching.MatchLocator.\nreportMatching(MatchLocator.java:2010)\n\tat org.eclipse.jdt.internal.core.search.matching.MatchLocator.\nprocess(MatchLocator.java:1458)\n\tat org.eclipse.jdt.internal.core.search.matching.MatchLocator.\nlocateMatches(MatchLocator.java:945)\n\tat org.eclipse.jdt.internal.core.search.matching.MatchLocator.\nlocateMatches(MatchLocator.java:986)\n\tat org.eclipse.jdt.internal.core.search.matching.MatchLocator.\nlocateMatches(MatchLocator.java:1088)\n\tat org.eclipse.jdt.internal.core.search.JavaSearchParticipant.\nlocateMatches(JavaSearchParticipant.java:94)\n\tat org.eclipse.jdt.internal.core.search.BasicSearchEngine.\nfindMatches(BasicSearchEngine.java:208)\n\tat org.eclipse.jdt.internal.core.search.BasicSearchEngine.\nsearch(BasicSearchEngine.java:424)\n\tat org.eclipse.jdt.core.search.SearchEngine.search(SearchEngine.java:532)\n\tat org.eclipse.jdt.internal.corext.refactoring.RefactoringSearchEngine2.\nsearchPattern(RefactoringSearchEngine2.java:471)\n\tat org.eclipse.jdt.internal.corext.refactoring.rename.RippleMethodFinder2.\nfindAllDeclarations(RippleMethodFinder2.java:290)\n\tat org.eclipse.jdt.internal.corext.refactoring.rename.RippleMethodFinder2.\ngetAllRippleMethods(RippleMethodFinder2.java:139)\n\tat org.eclipse.jdt.internal.corext.refactoring.rename.RippleMethodFinder2.\ngetRelatedMethods(RippleMethodFinder2.java:130)\n\tat org.eclipse.jdt.internal.corext.refactoring.rename.\nRenameMethodProcessor.initializeMethodsToRename(RenameMethodProcessor.java:157)\n\tat org.eclipse.jdt.internal.corext.refactoring.rename.\nRenameMethodProcessor.checkFinalConditions(RenameMethodProcessor.java:252)\n\tat org.eclipse.jdt.internal.corext.refactoring.rename.\nRenameVirtualMethodProcessor.checkFinalConditions(RenameVirtualMethodProcessor.\njava:111)\n\tat org.eclipse.ltk.core.refactoring.participants.\nProcessorBasedRefactoring.checkFinalConditions(ProcessorBasedRefactoring.java:\n169)\n\tat org.eclipse.ltk.core.refactoring.CheckConditionsOperation.\nrun(CheckConditionsOperation.java:84)\n\tat org.eclipse.ltk.core.refactoring.CreateChangeOperation.\nrun(CreateChangeOperation.java:114)\n\tat org.eclipse.core.internal.resources.Workspace.run(Workspace.java:1719)\n\tat org.eclipse.ltk.internal.ui.refactoring.WorkbenchRunnableAdapter.\nrun(WorkbenchRunnableAdapter.java:86)\n\tat org.eclipse.jface.operation.ModalContext$ModalContextThread.\nrun(ModalContext.java:113)\n----------------------------------------------------------------------\n\nPlease note:\nCaused by: java.lang.ArrayIndexOutOfBoundsException: 1\n\tat org.eclipse.jdt.internal.core.search.matching.MethodLocator.\nmatchOverriddenMethod(MethodLocator.java:290)\n\nIn this class, there is a bug on lines 290/292/294 (througth copy and paste of \ncode - note the wrong usage of ""i"" counter instead of ""j"" in the second ""for"" \nloop): \n\n\tfor (int i = 0; i<iLength; i++) {\n\t\tif (interfaces[i].isParameterizedType()) {\n\t\t\tMethodBinding[] methods = interfaces[i].getMethods(this.\npattern.selector);\n\t\t\tint length = methods.length;\n\t\t\tfor (int j = 0; j<length; j++) {\n\t\t\t\tif (methods[i].areParametersEqual(method)) {\n\t\t\t\t\tif (matchMethod == null) {\n\t\t\t\t\t\tif (methodParametersEqualsPattern(methods[i\n].original())) return true;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (methodsHaveSameParameters(methods[i].\noriginal(), matchMethod)) return true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (matchOverriddenMethod(interfaces[i], method, matchMethod)) {\n\t\t\treturn true;\n\t\t}\n\t}",,,,
102427,, Cannot inspect display static import methods  ,3.1.1,eclipse@skyluc.org,normal,P3,37071.86458,37090.44587,18.58128472,6,"Consider:\n\n---\npublic class Helper {\n    public static int getValue() {...}\n}\n---\nimport static Helper.*;\n\npublic class Doer {\n    public void doit() {\n        int i = getValue();\n    }\n}\n---\n\nWhen debugging, if you select 'getValue()' in the method 'doit' and execute\ndisplay (or inspect) you get an error indicating that the method 'getValue()' is\nnot undefined for type Doer.",,,,
100797,106202, editor general failure  ,3.1.1,david_audel@fr.ibm.com,normal,P3,37061.35139,37075.38823,14.03684028,71,"Hi,\nI was editing java class and suddenly all the editor collapse.\nSome how compiler error had managed to stop the editor.\nI could not open the java class to fix it. I could no build the project.\nThe line that causes this error was:\n\nString s = prefix "" Fail to insert record to db "" + e.getMessage();\n(Note: missing '+' between the prefix and the rest of the string)\n(I had to find it out using notepad since the eclipse stopped working)\n\n\nThe error console showed the following exceptions:\n\n\n\nError 2005-06-20 15:23:51.808 Error in JDT Core during AST creation\njava.lang.ClassCastException: \norg.eclipse.jdt.internal.compiler.ast.LocalDeclaration\n\tat \norg.eclipse.jdt.internal.compiler.parser.RecoveredMethod.updateFromParserState\n(RecoveredMethod.java:378)\n\tat org.eclipse.jdt.internal.compiler.parser.Parser.updateRecoveryState\n(Parser.java:9324)\n\tat org.eclipse.jdt.internal.compiler.parser.Parser.resumeOnSyntaxError\n(Parser.java:9258)\n\tat org.eclipse.jdt.internal.compiler.parser.Parser.parse\n(Parser.java:8440)\n\tat org.eclipse.jdt.internal.compiler.parser.Parser.parse\n(Parser.java:8739)\n\tat \norg.eclipse.jdt.internal.compiler.ast.MethodDeclaration.parseStatements\n(MethodDeclaration.java:116)\n\tat org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.parseMethod\n(TypeDeclaration.java:839)\n\tat org.eclipse.jdt.internal.compiler.parser.Parser.getMethodBodies\n(Parser.java:7818)\n\tat org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve\n(CompilationUnitResolver.java:787)\n\tat org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve\n(CompilationUnitResolver.java:498)\n\tat org.eclipse.jdt.core.dom.ASTParser.internalCreateAST\n(ASTParser.java:779)\n\tat org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:588)\n\tat org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run\n(ASTProvider.java:566)\n\tat org.eclipse.core.internal.runtime.InternalPlatform.run\n(InternalPlatform.java:1038)\n\tat org.eclipse.core.runtime.Platform.run(Platform.java:775)\n\tat org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST\n(ASTProvider.java:563)\n\tat org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST\n(ASTProvider.java:493)\n\tat \norg.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartList\nenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:165)\n\tat \norg.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$3.run\n(SelectionListenerWithASTManager.java:142)\n\tat org.eclipse.core.internal.jobs.Worker.run(Worker.java:76)\n\n\n\n\n\n\n\nError 2005-06-20 15:23:54.339 Problems occurred when invoking code from plug-\nin: ""org.eclipse.jdt.ui"".\njava.lang.ClassCastException: \norg.eclipse.jdt.internal.compiler.ast.LocalDeclaration\n\tat \norg.eclipse.jdt.internal.compiler.parser.RecoveredMethod.updateFromParserState\n(RecoveredMethod.java:378)\n\tat org.eclipse.jdt.internal.compiler.parser.Parser.updateRecoveryState\n(Parser.java:9324)\n\tat org.eclipse.jdt.internal.compiler.parser.Parser.resumeOnSyntaxError\n(Parser.java:9258)\n\tat org.eclipse.jdt.internal.compiler.parser.Parser.parse\n(Parser.java:8440)\n\tat org.eclipse.jdt.internal.compiler.parser.Parser.parse\n(Parser.java:8739)\n\tat \norg.eclipse.jdt.internal.compiler.ast.MethodDeclaration.parseStatements\n(MethodDeclaration.java:116)\n\tat org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.parseMethod\n(TypeDeclaration.java:839)\n\tat org.eclipse.jdt.internal.compiler.parser.Parser.getMethodBodies\n(Parser.java:7818)\n\tat org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve\n(CompilationUnitResolver.java:787)\n\tat org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve\n(CompilationUnitResolver.java:498)\n\tat org.eclipse.jdt.core.dom.ASTParser.internalCreateAST\n(ASTParser.java:779)\n\tat org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:588)\n\tat org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run\n(ASTProvider.java:566)\n\tat org.eclipse.core.internal.runtime.InternalPlatform.run\n(InternalPlatform.java:1038)\n\tat org.eclipse.core.runtime.Platform.run(Platform.java:775)\n\tat org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST\n(ASTProvider.java:563)\n\tat org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST\n(ASTProvider.java:493)\n\tat \norg.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo\n(NLSStringHover.java:84)\n\tat \norg.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo\n(BestMatchHover.java:102)\n\tat \norg.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInf\no(JavaEditorTextHoverProxy.java:69)\n\tat org.eclipse.jface.text.TextViewerHoverManager$4.run\n(TextViewerHoverManager.java:160)",,,,
109104,, Editor save does not write to disk (intermittent)  ,3.1.1,daniel_megert@ch.ibm.com,critical,P1,37141.73264,37153.54071,11.80806713,43,"Build: I20050906-1200\n\nSeveral times while using this build, I have hit save in an editor but the\nbuffer contents have not been flushed to disk.  When this happens, the file on\ndisk has the same contents as the previous save, but the ""Save"" action is greyed\nout and the dirty indicator (*) is gone from the editor tab.  There are no\nerrors in the log file or on the Java console.\n\nThe first couple of times this happened, I thought it was an error in the\ndebugger because my breakpoints and stepping were not lining up with the correct\ncode. However, it just happened again, and I opened the same file in Wordpad to\ndiscover that the editor contents do not match the contents in Wordpad.  Each\ntime this happened, dirtying the editor again and hitting save again would flush\nthe correct contents to disk.\n\nI have not been able to reproduce it consistently, but here is what I did the\nmost recent time it happened.\n\n1) Did a search and replace in a Java file (Ctrl+F, Replace All)\n2) Hit save.\n3) Discovered that I replaced with the wrong thing\n4) Hit Undo (Ctrl+Z)\n5) Did another search and replace with the correct value\n6) Hit Save.\n\nThe editor now looks correct, but the file on disk still looks like it was in\nstep 2). I will attach a screen shot in case it helps clarify.",,,,
102305,, Error in JDT Core during reconcile  ,3.1.1,Olivier_Thomann@ca.ibm.com,normal,P3,37071.34583,37072.51086,1.165023148,2,I have seen this worrying message in the Eclipse log file:\n\nError in JDT Core during reconcile\n\njava.lang.NullPointerException\nat org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1127)\nat org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:261)\nat\norg.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:84)\nat org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:718)\nat\norg.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:777)\nat\norg.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1081)\nat\norg.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:98)\nat\norg.eclipse.core.internal.runtime.InternalPlatform.run(InternalPlatform.java:1044)\nat org.eclipse.core.runtime.Platform.run(Platform.java:783)\nat\norg.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:82)\nat\norg.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:147)\nat\norg.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)\nat\norg.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:94)\nat org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:75)\nat org.eclipse.jdt.internal.ui.text.JavaReconciler.process(JavaReconciler.java:339)\nat\norg.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:204),,,,
102422,, Exception referencing class in large jar files  ,3.1.1,jerome_lanneluc@fr.ibm.com,normal,P3,37071.81597,37119.41226,47.59628472,47,"(This is in 3.1 RC1.) The build path of a project in my workspace includes a 48\nMb jar with 30,000 files in it scattered among 1000-2000 packages. (The jar file\nis proprietary so I can't attach it.) The Java editor frequently indicates that\nreferences to classes in this jar cannot be resolved, even though the classes\nare there. The attached stack trace shows what seems to be the root cause of\nthis behavior. (The JavaModelException is caught and ignored.)",,,,
106514,, [1.5][compiler] Improve diagnostic on bound mismatch for GenericTypeTests.test790  ,3.1.1,philippe_mulet@fr.ibm.com,normal,P3,37111.51875,37113.2513,1.732546296,215,"(Fup on bug 103485)\n\nWhile bug 103485 is fixed with 3.2 M1 (we definitely have an error diagnostic \nnow), the message is a bit difficult to understand, since it does not cite the \neffective types of the arguments, but complex types yield by the validation \nand capture algorithm, which relationship to the arguments is not easy to \ngrasp.\n\nPhilippe's suggestion for an improved message:\nBound mismatch: The generic method isGreater(T, T) of type Hover is not \napplicable for the arguments (Integer, Double) since the type \nNumber&Comparable<?> is not a valid substitute for the bounded parameter <T \nextends Comparable<T>>\n(maybe even without the since... part of it)",,,,
107706,, Infer type arguments does not add type arguments to fully qualified types  ,3.1.1,markus_keller@ch.ibm.com,normal,P3,37125.25764,37125.39139,0.13375,20,public class A {\n\tA() {\n\t\tjava.util.List list= new java.util.ArrayList(),\n\t\tlist.add(1),\n\t}\n},,
106202,, JavaModelCache should have configurable LRU cache limits  ,3.1.1,jerome_lanneluc@fr.ibm.com,enhancement,P3,37107.52569,37135.36164,27.83594907,38,"We are working with the classpath container extension point and found that if we\nadd a lot of jars to our container, the JDT starts thrashing the garbage\ncollector.  Upon further investigation, we found that there is a limit of 2000\npackages in the package cache in the JavaModelCache.  Every time I delete and\nreadd a semicolon and resave the file, the model cache appears to go rebuild the\ncache data for all of those jars (even though I'm not actually referencing all\nof them from my code) and this makes the garbage collector thrash.  Looking at\nthe code, it appears that 2000 is a hardcoded limit.  There is a setSpaceLimit()\nmethod on LRUCache, but the class is internal, and I don't see a public way to\nget the cache pointer anyway.  \n\nSo even though I'm running with -Xmx512m, I'm thrashing memory at a much lower\nlevel than that, and I don't see a workaround other than to not add so many jars\nto my classpath.",,,,
103636,, JDT compiler produces invalid XML  ,3.1.1,Olivier_Thomann@ca.ibm.com,normal,P3,37084.32083,37085.5984,1.277569444,2,"Hi,\n\nif the JDT compiler encounters compile errors, the produced XML log file is not \nvalid (it doesn't has a </sources> element). \n\nI'm calling this compiler from Ant like this:\n\n<java fork=""true"" \n      jar=""C:/java/tools/org.eclipse.jdt.core_3.1.0.jar"">\n    <arg line=""-cp ${jdt-compile.classpath}"" />\n    <arg line=""-d none"" />\n    <arg line=""-warn:deprecation"" />\n    <arg line=""-source 1.4""/>\n    <arg line=""-log ${build.reports.deprecated}/compile-warnings.xml"" />\n    <arg line=""${src.dir} ${src.test.dir}"" />\n</java>\n\nregards,\nMaarten",,,,
103320,, Method-local subtype with instance initializer break JDOM  ,3.1.1,Olivier_Thomann@ca.ibm.com,normal,P3,37082.44097,37085.61325,3.172280093,8,"1) Begin with a plugin project with a java annotated emf model that can be \nsuccessfully reloaded.\n\n2) Add a non-emf model class in any package such as:\n\npublic class EmfReloadBug {\n public void buggyMethod() {\n  Object o = new Object() {\n   {\n    System.out.println(""EMF reload does not like this method local subtype \ninstance init"");\n   }\n  }\n }\n}\n\n3) Try to reload the genmodel. the package selection page for the reload \nwizard is empty and throws the following exception:\n\norg.eclipse.jdt.core.jdom.DOMException: Attempt to add child to node that \ncannot have children",,,,
103326,, NPE executing step into command  ,3.1.1,Darin_Wright@ca.ibm.com,normal,P3,37082.44931,37096.42883,13.97952546,12,"I've been testing debugging (using the\nJavaRemoteApplicationLaunchConfigurationDelegate) for a simple servlet deployed\nto a generic WLS server and unexpectedly hit an NPE during one debugging session\n(the ""Use Step Filters/Step Debug"" had been selected and deselecting that\nallowed me to continue debugging):\n\n!ENTRY org.eclipse.core.runtime 4 2 2005-07-11 10:36:50.890\n!MESSAGE An internal error occurred during: ""Step Over"".\n!STACK 0\njava.lang.NullPointerException\n\tat\norg.eclipse.jdt.internal.debug.core.model.JDIThread$StepHandler.attachFiltersToStepRequest(JDIThread.java:1846)\n\tat\norg.eclipse.jdt.internal.debug.core.model.JDIThread$StepHandler.createStepRequest(JDIThread.java:1756)\n\tat\norg.eclipse.jdt.internal.debug.core.model.JDIThread$StepHandler.step(JDIThread.java:1704)\n\tat\norg.eclipse.jdt.internal.debug.core.model.JDIThread.stepOver(JDIThread.java:1234)\n\tat\norg.eclipse.debug.internal.ui.actions.StepOverActionDelegate.stepAction(StepOverActionDelegate.java:30)\n\tat\norg.eclipse.debug.internal.ui.actions.StepActionDelegate.doAction(StepActionDelegate.java:25)\n\tat\norg.eclipse.debug.internal.ui.actions.AbstractDebugActionDelegate$DebugRequestJob.run(AbstractDebugActionDelegate.java:150)\n\tat org.eclipse.core.internal.jobs.Worker.run(Worker.java:76)",,,,
101955,, NullPointerException after invoking extract method  ,3.1.1,Olivier_Thomann@ca.ibm.com,normal,P3,37068.8875,37071.71429,2.826793981,109,"3.1RC4 (Build id: I20050624-1300)\n\nWhen trying to extract a method I get the error:\n""An unexpected exception occurred during condition checking.""\n\nUnfortunately I don't have a reproducible test case; the exception happens when\ntrying to extract a method out of one particular area of my code but not in\nother similar areas.\n\nfrom the error log:\n\njava.lang.reflect.InvocationTargetException\n\tat org.eclipse.jface.operation.ModalContext.run(ModalContext.java:327)\n\tat\norg.eclipse.jface.dialogs.ProgressMonitorDialog.run(ProgressMonitorDialog.java:447)\n\tat\norg.eclipse.ui.internal.progress.ProgressMonitorJobsDialog.run(ProgressMonitorJobsDialog.java:261)\n\tat org.eclipse.ui.internal.progress.ProgressManager$3.run(ProgressManager.java:861)\n\tat org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:69)\n\tat\norg.eclipse.ui.internal.progress.ProgressManager.busyCursorWhile(ProgressManager.java:895)\n\tat\norg.eclipse.ui.internal.progress.ProgressManager.busyCursorWhile(ProgressManager.java:871)\n\tat\norg.eclipse.ltk.ui.refactoring.RefactoringWizardOpenOperation.checkInitialConditions(RefactoringWizardOpenOperation.java:150)\n\tat\norg.eclipse.ltk.ui.refactoring.RefactoringWizardOpenOperation.access$0(RefactoringWizardOpenOperation.java:146)\n\tat\norg.eclipse.ltk.ui.refactoring.RefactoringWizardOpenOperation$1.run(RefactoringWizardOpenOperation.java:116)\n\tat org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:69)\n\tat\norg.eclipse.ltk.ui.refactoring.RefactoringWizardOpenOperation.run(RefactoringWizardOpenOperation.java:138)\n\tat\norg.eclipse.jdt.internal.ui.refactoring.actions.RefactoringStarter.activate(RefactoringStarter.java:40)\n\tat org.eclipse.jdt.ui.actions.ExtractMethodAction.run(ExtractMethodAction.java:84)\n\tat\norg.eclipse.jdt.ui.actions.SelectionDispatchAction.dispatchRun(SelectionDispatchAction.java:226)\n\tat\norg.eclipse.jdt.ui.actions.SelectionDispatchAction.run(SelectionDispatchAction.java:198)\n\tat org.eclipse.jface.action.Action.runWithEvent(Action.java:996)\n\tat org.eclipse.ui.commands.ActionHandler.execute(ActionHandler.java:182)\n\tat\norg.eclipse.ui.internal.handlers.LegacyHandlerWrapper.execute(LegacyHandlerWrapper.java:108)\n\tat org.eclipse.core.commands.Command.execute(Command.java:311)\n\tat\norg.eclipse.core.commands.ParameterizedCommand.execute(ParameterizedCommand.java:396)\n\tat\norg.eclipse.ui.internal.keys.WorkbenchKeyboard.executeCommand(WorkbenchKeyboard.java:459)\n\tat org.eclipse.ui.internal.keys.WorkbenchKeyboard.press(WorkbenchKeyboard.java:781)\n\tat\norg.eclipse.ui.internal.keys.WorkbenchKeyboard.processKeyEvent(WorkbenchKeyboard.java:828)\n\tat\norg.eclipse.ui.internal.keys.WorkbenchKeyboard.filterKeySequenceBindings(WorkbenchKeyboard.java:550)\n\tat\norg.eclipse.ui.internal.keys.WorkbenchKeyboard.access$3(WorkbenchKeyboard.java:493)\n\tat\norg.eclipse.ui.internal.keys.WorkbenchKeyboard$KeyDownFilter.handleEvent(WorkbenchKeyboard.java:117)\n\tat org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:66)\n\tat org.eclipse.swt.widgets.Display.filterEvent(Display.java:917)\n\tat org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:842)\n\tat org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:867)\n\tat org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:852)\n\tat org.eclipse.swt.widgets.Widget.sendKeyEvent(Widget.java:880)\n\tat org.eclipse.swt.widgets.Widget.sendKeyEvent(Widget.java:876)\n\tat org.eclipse.swt.widgets.Widget.wmKeyDown(Widget.java:1475)\n\tat org.eclipse.swt.widgets.Control.WM_KEYDOWN(Control.java:3348)\n\tat org.eclipse.swt.widgets.Control.windowProc(Control.java:3067)\n\tat org.eclipse.swt.widgets.Display.windowProc(Display.java:3706)\n\tat org.eclipse.swt.internal.win32.OS.DispatchMessageW(Native Method)\n\tat org.eclipse.swt.internal.win32.OS.DispatchMessage(OS.java:1656)\n\tat org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:2711)\n\tat org.eclipse.ui.internal.Workbench.runEventLoop(Workbench.java:1699)\n\tat org.eclipse.ui.internal.Workbench.runUI(Workbench.java:1663)\n\tat org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:367)\n\tat org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:143)\n\tat org.eclipse.ui.internal.ide.IDEApplication.run(IDEApplication.java:103)\n\tat\norg.eclipse.core.internal.runtime.PlatformActivator$1.run(PlatformActivator.java:226)\n\tat org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:376)\n\tat org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:163)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)\n\tat\nsun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)\n\tat java.lang.reflect.Method.invoke(Method.java:585)\n\tat org.eclipse.core.launcher.Main.invokeFramework(Main.java:334)\n\tat org.eclipse.core.launcher.Main.basicRun(Main.java:278)\n\tat org.eclipse.core.launcher.Main.run(Main.java:973)\n\tat org.eclipse.core.launcher.Main.main(Main.java:948)\nCaused by: java.lang.NullPointerException\n\tat org.eclipse.jdt.internal.corext.dom.Bindings.equals(Bindings.java:88)\n\tat\norg.eclipse.jdt.internal.corext.refactoring.code.SnippetFinder$Matcher.match(SnippetFinder.java:107)\n\tat org.eclipse.jdt.core.dom.SimpleName.subtreeMatch0(SimpleName.java:140)\n\tat org.eclipse.jdt.core.dom.ASTNode.subtreeMatch(ASTNode.java:2315)\n\tat org.eclipse.jdt.core.dom.ASTMatcher.safeSubtreeMatch(ASTMatcher.java:138)\n\tat org.eclipse.jdt.core.dom.ASTMatcher.match(ASTMatcher.java:1386)\n\tat\norg.eclipse.jdt.core.dom.MethodInvocation.subtreeMatch0(MethodInvocation.java:229)\n\tat org.eclipse.jdt.core.dom.ASTNode.subtreeMatch(ASTNode.java:2315)\n\tat\norg.eclipse.jdt.internal.corext.refactoring.code.SnippetFinder.matches(SnippetFinder.java:204)\n\tat\norg.eclipse.jdt.internal.corext.refactoring.code.SnippetFinder.visitNode(SnippetFinder.java:191)\n\tat\norg.eclipse.jdt.internal.corext.dom.GenericVisitor.visit(GenericVisitor.java:142)\n\tat org.eclipse.jdt.core.dom.MethodInvocation.accept0(MethodInvocation.java:236)\n\tat org.eclipse.jdt.core.dom.ASTNode.accept(ASTNode.java:2450)\n\tat org.eclipse.jdt.core.dom.ASTNode.acceptChild(ASTNode.java:2497)\n\tat\norg.eclipse.jdt.core.dom.VariableDeclarationFragment.accept0(VariableDeclarationFragment.java:224)\n\tat org.eclipse.jdt.core.dom.ASTNode.accept(ASTNode.java:2450)\n\tat org.eclipse.jdt.core.dom.ASTNode.acceptChildren(ASTNode.java:2520)\n\tat\norg.eclipse.jdt.core.dom.VariableDeclarationStatement.accept0(VariableDeclarationStatement.java:272)\n\tat org.eclipse.jdt.core.dom.ASTNode.accept(ASTNode.java:2450)\n\tat org.eclipse.jdt.core.dom.ASTNode.acceptChildren(ASTNode.java:2520)\n\tat org.eclipse.jdt.core.dom.Block.accept0(Block.java:135)\n\tat org.eclipse.jdt.core.dom.ASTNode.accept(ASTNode.java:2450)\n\tat org.eclipse.jdt.core.dom.ASTNode.acceptChild(ASTNode.java:2497)\n\tat org.eclipse.jdt.core.dom.IfStatement.accept0(IfStatement.java:189)\n\tat org.eclipse.jdt.core.dom.ASTNode.accept(ASTNode.java:2450)\n\tat org.eclipse.jdt.core.dom.ASTNode.acceptChildren(ASTNode.java:2520)\n\tat org.eclipse.jdt.core.dom.Block.accept0(Block.java:135)\n\tat org.eclipse.jdt.core.dom.ASTNode.accept(ASTNode.java:2450)\n\tat org.eclipse.jdt.core.dom.ASTNode.acceptChild(ASTNode.java:2497)\n\tat org.eclipse.jdt.core.dom.IfStatement.accept0(IfStatement.java:189)\n\tat org.eclipse.jdt.core.dom.ASTNode.accept(ASTNode.java:2450)\n\tat org.eclipse.jdt.core.dom.ASTNode.acceptChildren(ASTNode.java:2520)\n\tat org.eclipse.jdt.core.dom.Block.accept0(Block.java:135)\n\tat org.eclipse.jdt.core.dom.ASTNode.accept(ASTNode.java:2450)\n\tat org.eclipse.jdt.core.dom.ASTNode.acceptChild(ASTNode.java:2497)\n\tat org.eclipse.jdt.core.dom.MethodDeclaration.accept0(MethodDeclaration.java:501)\n\tat org.eclipse.jdt.core.dom.ASTNode.accept(ASTNode.java:2450)\n\tat org.eclipse.jdt.core.dom.ASTNode.acceptChildren(ASTNode.java:2520)\n\tat org.eclipse.jdt.core.dom.TypeDeclaration.accept0(TypeDeclaration.java:483)\n\tat org.eclipse.jdt.core.dom.ASTNode.accept(ASTNode.java:2450)\n\tat\norg.eclipse.jdt.internal.corext.refactoring.code.SnippetFinder.perform(SnippetFinder.java:138)\n\tat\norg.eclipse.jdt.internal.corext.refactoring.code.ExtractMethodRefactoring.initializeDuplicates(ExtractMethodRefactoring.java:581)\n\tat\norg.eclipse.jdt.internal.corext.refactoring.code.ExtractMethodRefactoring.checkInitialConditions(ExtractMethodRefactoring.java:247)\n\tat\norg.eclipse.ltk.core.refactoring.CheckConditionsOperation.run(CheckConditionsOperation.java:82)\n\tat org.eclipse.core.internal.resources.Workspace.run(Workspace.java:1719)\n\tat\norg.eclipse.ltk.internal.ui.refactoring.WorkbenchRunnableAdapter.run(WorkbenchRunnableAdapter.java:86)\n\tat\norg.eclipse.jface.operation.ModalContext$ModalContextThread.run(ModalContext.java:113)",,,,
109646,, [DOM] Parsing using K_STATEMENTS doesn't return the right tree for multiple local declarations  ,3.1.1,Olivier_Thomann@ca.ibm.com,normal,P3,37148.6,37148.61686,0.016863426,42,"The following source:\n\nString s, t, u, v;\n\nends up as four statements (VariableDeclarationStatement) instead of one\nstatement with four fragments.",,,,
102778,, Scrapbook page doesn't work with enhanced for statement  ,3.1.1,Olivier_Thomann@ca.ibm.com,normal,P3,37076.65278,37077.72258,1.069803241,101,"Using 3.1, create a new java project.\nAdd a new scrapbook page that contains this source:\n \nint[] tab = new int[] {1, 2, 3, 4, 5, 6, 7, 8, 9 };\nint sum = 0;\nfor (int i : tab) {\n\tsum += i;\n}\nsum\n\nYou get an error about syntax error.",,,,
97220,, Should not issue nls warning for annotation  ,3.1.1,Olivier_Thomann@ca.ibm.com,normal,P3,37040.29375,37071.53169,31.23793981,424,"3.1 RC1\n\nIn the following case, we issue a 'Non-externalized string literal' warning for\n""deprecation"":\n@SuppressWarnings(""deprecation"")\npublic class X {\n}\n\nHowever this is always a constant (and will never be externalized). We should\nnot issue a 'Non-externalized string literal' warning here (and for any\nannotation in general).",,,,
103466,, Stack Overflow: Requesting Java AST from selection  ,3.1.1,jerome_lanneluc@fr.ibm.com,normal,P3,37083.25833,37134.30902,51.05068287,108,"The bug occurs in Eclipse 3.1, whereas in 3.0 everything is fine.\n\nThe error-message I get is ""An internal error occurred during 'Requesting Java \nAST from selection'"", resulting from the following stack-trace in the Eclipse-\nlog (Note that the stack overflow seems to result from a loop):\n\n!ENTRY org.eclipse.core.runtime 4 2 2005-07-12 09:31:35.365\n!MESSAGE An internal error occurred during: ""Requesting Java AST from \nselection"".\n!STACK 0\njava.lang.StackOverflowError\n\tat org.eclipse.jdt.internal.core.JavaElement.getElementInfo\n(JavaElement.java:230)\n\tat org.eclipse.jdt.internal.core.JavaElement.getElementInfo\n(JavaElement.java:218)\n\tat org.eclipse.jdt.internal.core.PackageFragmentRoot.getKind\n(PackageFragmentRoot.java:538)\n\tat org.eclipse.jdt.internal.core.PackageFragment.getKind\n(PackageFragment.java:268)\n\tat org.eclipse.jdt.internal.core.PackageFragment.getClassFiles\n(PackageFragment.java:177)\n\tat org.eclipse.jdt.internal.core.NameLookup.seekTypesInBinaryPackage\n(NameLookup.java:793)\n\tat org.eclipse.jdt.internal.core.NameLookup.seekTypes\n(NameLookup.java:769)\n\tat org.eclipse.jdt.internal.core.NameLookup.findType\n(NameLookup.java:542)\n\tat org.eclipse.jdt.internal.core.NameLookup.findType\n(NameLookup.java:501)\n\tat org.eclipse.jdt.internal.core.SearchableEnvironment.find\n(SearchableEnvironment.java:85)\n\tat org.eclipse.jdt.internal.core.SearchableEnvironment.findType\n(SearchableEnvironment.java:177)\n\tat org.eclipse.jdt.internal.core.CancelableNameEnvironment.findType\n(CancelableNameEnvironment.java:50)\n\tat org.eclipse.jdt.internal.compiler.lookup.LookupEnvironment.askForType\n(LookupEnvironment.java:93)\n\tat \norg.eclipse.jdt.internal.compiler.lookup.UnresolvedReferenceBinding.resolve\n(UnresolvedReferenceBinding.java:43)\n\tat \norg.eclipse.jdt.internal.compiler.lookup.BinaryTypeBinding.resolveUnresolvedType\n(BinaryTypeBinding.java:92)\n\tat \norg.eclipse.jdt.internal.compiler.lookup.BinaryTypeBinding.enclosingType\n(BinaryTypeBinding.java:516)\n\tat org.eclipse.jdt.internal.compiler.lookup.BinaryTypeBinding.<init>\n(BinaryTypeBinding.java:144)\n\tat \norg.eclipse.jdt.internal.compiler.lookup.LookupEnvironment.createBinaryTypeFrom\n(LookupEnvironment.java:468)\n\tat \norg.eclipse.jdt.internal.compiler.lookup.LookupEnvironment.createBinaryTypeFrom\n(LookupEnvironment.java:465)\n\tat org.eclipse.jdt.internal.compiler.Compiler.accept(Compiler.java:190)\n\n........ (many times the same) ........\n\n\tat org.eclipse.jdt.internal.compiler.Compiler.accept(Compiler.java:190)\n\tat org.eclipse.jdt.internal.compiler.lookup.LookupEnvironment.askForType\n(LookupEnvironment.java:99)\n\tat \norg.eclipse.jdt.internal.compiler.lookup.UnresolvedReferenceBinding.resolve\n(UnresolvedReferenceBinding.java:43)\n\tat \norg.eclipse.jdt.internal.compiler.lookup.BinaryTypeBinding.resolveUnresolvedType\n(BinaryTypeBinding.java:92)\n\tat \norg.eclipse.jdt.internal.compiler.lookup.BinaryTypeBinding.enclosingType\n(BinaryTypeBinding.java:516)\n!SESSION 2005-07-12 09:31:44.729 -----------------------------------------------\neclipse.buildId=I20050627-1435\njava.version=1.5.0_04\njava.vendor=Sun Microsystems Inc.\nBootLoader constants: OS=win32, ARCH=x86, WS=win32, NL=de_DE\nCommand-line arguments:  -os win32 -ws win32 -arch x86\n\n\nThe error happens when clicking anywhere in an editor-window containing the \nfollowing code:\n\npackage dvl.tst;\nimport dev.etd.CAConfMsgSet.Helper;\npublic class AstTest    {\n\tpublic AstTest() { \n\t\tHelper sec = new Helper();\n\t\tsec.get$1().get$2().get$3().getSfkpngPlaceString();\n\t}\n}\n\nwhere Helper has the following content (simplified to make tracking easier):\n\npackage dev.etd.CAConfMsgSet;\npublic class Helper {\n  public void init() {\n  }\n  public static class $1 {\n    public static class $2 {\n      public static class $3 {\n        public java.lang.String getSfkpngPlaceString() {\n          return ""String""; \n        }\n      }\n      $3 _$3;\n      public $3 get$3() {\n        if (_$3 == null) _$3 = new $3();\n        return _$3;\n      }\n    }\n    $2 _$2;\n    public $2 get$2() {\n      if (_$2 == null) {_$2 = new $2();}\n      return _$2;\n    }\n  }\n  $1 _$1;\n  public $1 get$1() {\n    if (_$1 == null) _$1 = new $1();\n    return _$1;\n  }\n}\n\nPlease note that the error only happens when Helper-class is packaged in a jar-\nfile.\n\nSetup for the test: Just the java-file above in the project plus the class-file \npackaged in a jar (nothing else).",,,,
107735,, StringIndexOutOfBoundsException in Util.getNameWithoutJavaLikeExtension()  ,3.1.1,jerome_lanneluc@fr.ibm.com,major,P3,37125.46736,37134.383,8.915636574,29,"With AJDT (AspectJ dev tools) installed users are reporting exceptions like this:\nCaused by: java.lang.StringIndexOutOfBoundsException: String index out of range: -1\nat java.lang.String.substring(String.java:1768)\nat\norg.eclipse.jdt.internal.core.util.Util.getNameWithoutJavaLikeExtension(Util.java:839)\nat\norg.eclipse.jdt.internal.core.search.matching.PossibleMatch.getQualifiedName(PossibleMatch.java:101)\nat\norg.eclipse.jdt.internal.core.search.matching.PossibleMatch.<init>(PossibleMatch.java:41)\nat\norg.eclipse.jdt.internal.core.search.matching.MatchLocator.locateMatches(MatchLocator.java:1097)\nat\norg.eclipse.jdt.internal.core.search.JavaSearchParticipant.locateMatches(JavaSearchParticipant.java:94)\nat\norg.eclipse.jdt.internal.core.search.BasicSearchEngine.findMatches(BasicSearchEngine.java:208)\nat\norg.eclipse.jdt.internal.core.search.BasicSearchEngine.search(BasicSearchEngine.java:424)\nat org.eclipse.jdt.core.search.SearchEngine.search(SearchEngine.java:532)\nat\norg.eclipse.jdt.internal.corext.refactoring.RefactoringSearchEngine.findAffectedCompilationUnits(RefactoringSearchEngine.java:72)\nat\norg.eclipse.jdt.internal.corext.refactoring.rename.RenameTypeProcessor.checkConflictingTypes(RenameTypeProcessor.java:593)\n\nSee AJDT bug 98547 for more details of the scenarios in which this occurs. Note\nthat the problem can happen in regular Java projects, but of course only with\nAJDT in the picture.\n\nThis happens because AJDT defines subtypes of CompilationUnit for aspects\ncontained in .aj files.\n\nUtil.getNameWithoutJavaLikeExtension (in the ""model"" source folder)\ncurrently looks like this:\n\n\t/**\n\t * Returns the substring of the given file name, ending at the start of a Java\nlike extension.\n\t */\n\tpublic static String getNameWithoutJavaLikeExtension(String fileName) {\n\t\tint index = indexOfJavaLikeExtension(fileName);\n\t\treturn fileName.substring(0, index);\n\t}\n\nSo it is getting called with a name like ""MyAspect.aj"", and the\nindexOfJavaLikeExtension() method is then returning -1, resulting in the out of\nbounds exception on the next line.\n\nThe fix is therefore to simply make the method more robust, such as:\n\n\t/**\n\t * Returns the substring of the given file name, ending at the start of a\n\t * Java like extension. The entire file name is returned if it doesn't end\n\t * with a Java like extension.\n\t */\n\tpublic static String getNameWithoutJavaLikeExtension(String fileName) {\n\t\tint index = indexOfJavaLikeExtension(fileName);\n\t\tif (index == -1) {\n\t\t\treturn fileName;\n\t\t}\n\t\treturn fileName.substring(0, index);\n\t}",,,,
104780,, TVT 3.1: TCT 386 - wrong description for option FORMATTER_INSERT_NEW_LINE_AFTER_ANNOTATION  ,3.1.1,Olivier_Thomann@ca.ibm.com,normal,P3,37093.31111,37106.50135,13.19024306,4,"The option FORMATTER_INSERT_NEW_LINE_AFTER_ANNOTATION in \neclipse\\plugins\\org.eclipse.jdt.doc.isv\\doc_zip\\guide\\jdt_api_options.htm has \na description of: \n\nOption to insert a new line after the opening brace in an array initializer \n\nPlease confirm if that's incorrect description, and should read:\n\nOption to insert a new line after annotation",,,,
91426,, [Markers] Java task tags in Task View don't have configured priority  ,3.1.1,Olivier_Thomann@ca.ibm.com,normal,P3,36994.52986,37082.45046,87.92060185,217,"I just switched from 3.1M5 to 3.1M6 and I noticed that High and Low priority\ntasks from Java files (configured via\nWindows|Preferences|Java|Compiler|Error/Warnings) no longer have their correct\npriority in the view. They have no icon specified, which I assume means normal\npriority.\n\nAdditionally, the tasks are now editable, so I can mark them as completed and\nchange the description. However, this has no relation to the Java file they\noriginated from, i.e. it doesn't update the comment text in the .java. I don't\nthink I would want that anyways, but if compiler-generated tasks are going to be\neditable in Task View, they should tie back to the source.\n\nI couldn't find anything in the build notes or help for 3.1m6. I didn't see any\nway to configure the editablility of .java tasks -- I liked the m5 style where\njava tasks are non-editable in the Task View. When I switched to m6, I reused\nthe same workspace, but it happens in a new workspace as well.",,,,
97326,," [dom] ITypeBinding#isFromSource() is always false for type variables, wildcards, and capture types  ",3.1.1,Olivier_Thomann@ca.ibm.com,normal,P3,37040.57222,37076.58095,36.00872685,42,"I20050527-1300\n\nITypeBinding#isFromSource() is currently always false for type variables,\nwildcards, and capture types. Javadoc tells a different story.\n\nI would expect true iff a type variable or a capture binding originates from\nsource. For wildcards, I guess the query should always return false (since\nwildcard bindings are the same whether they're from source or from binary). The\njavadoc should tell that.",,,,
98532,, [1.5][compiler] Spurious 'type parameter T is hiding the type T' warning for static nested classes  ,3.1.1,david_audel@fr.ibm.com,minor,P3,37047.48056,37302.20081,254.7202546,185,"See comments in test code snippet:\n\npublic class Gen<T> {\n\tstatic class StaticInnerNoParam {\n                // Compiler error on the following line -- \n                // ""Cannot make a static reference to non-static type T""\n                // This is expected\n\t\tT x;\n\t}\n\n        // Warning reported on the following line --\n        // ""The type parameter T is hiding the type T"" \n        // Perhaps this is technically true? (I'm not quite sure what\n        //     the Java spec says about this.) But the outer T cannot\n        //     be used in this scope anyway, so it seems that the\n        //     warning is not really beneficial. I use the same names\n        //     for corresponding type parameters between the outer\n        //     class and static inner classes, so this generates\n        //     unnecessary warnings for me.\n\tstatic class StaticInnerParam<T> {\n\t\n\t}\n}",,,,
99662,, [1.5] JavaModel returns inexistent IType for package-info ICompilationUnits  ,3.1.1,frederic_fusier@fr.ibm.com,normal,P3,37054.43403,37118.43231,63.99828704,30,"3.1 RC2\n\nSteps to reproduce:\n- Create Java project, use project folder as source folder and output folder\n- Create package p\n- Create package-info.java in package p\n- Annotate package declaration in package-info.java with @Deprecated\n\n-> Package Explorer and Outline show an inexistent interface package-info. The \noutline does not show a package declaration.\n\n-> I would exspect the JavaModel to return a package declaration only",,,,
99903,99662, [1.5][search] range wrong for package-info  ,3.1.1,frederic_fusier@fr.ibm.com,normal,P3,37055.18125,37117.62792,62.44666667,1010,3.1 RC2\n\nrange wrong for package-info.\n\nFollow steps in bug 99812 but select 'package-info' ==> only the '@' gets\nselected due to the wrong range (see attached picture).,,,,
100211,," [source actions] Strange behavior in ""Generate Constructor using Fields""  ",3.1.1,tobias_widmer@ch.ibm.com,minor,P3,37056.47639,37117.19456,60.7181713,30,"I find the behavior of ""Generate Constructor using Fields"" is strange in some\ncase. Suppose you have the following file:\n\nclass ID {\n\tprivate int publicPart;\n\tprivate int localPart;\n}\n\nThen when you call ""Generate Constructor using Fields"", it generates:\n\npublic ID(int part, int part2) {\n\tsuper();\n\t// TODO Auto-generated constructor stub\n\tpublicPart = part;\n\tlocalPart = part2;\n}\n\nI don't known why the names of the two arguments are ""part"" and ""part2"", instead\nof ""publicPart"" and ""localPart"".\n\nThe first line of the generated code, ""super()"", is also unnessary. So I think\nit will be better if you delete this line if the class does not inherit from\nother class (except Object).",,,,
100606,103994, NPE during reconcile  ,3.1.1,jerome_lanneluc@fr.ibm.com,normal,P3,37058.51181,37134.39984,75.88803241,102,I found an NPE in my console but i don't know how to reproduce it and i have no\ntest case.\n\n!ENTRY org.eclipse.jdt.ui 4 0 2005-06-17 17:06:30.296\n!MESSAGE Error in JDT Core during reconcile\n!STACK 0\njava.lang.NullPointerException\n        at\norg.eclipse.jdt.internal.compiler.lookup.TypeVariableBinding.genericSignature(TypeVariableBinding.java:271)\n        at\norg.eclipse.jdt.internal.compiler.lookup.MethodBinding.genericSignature(MethodBinding.java:364)\n        at\norg.eclipse.jdt.internal.compiler.lookup.MethodBinding.computeUniqueKey(MethodBinding.java:321)\n        at\norg.eclipse.jdt.internal.compiler.lookup.MethodBinding.computeUniqueKey(MethodBinding.java:310)\n        at\norg.eclipse.jdt.internal.compiler.lookup.TypeVariableBinding.computeUniqueKey(TypeVariableBinding.java:242)\n        at\norg.eclipse.jdt.internal.compiler.lookup.Binding.computeUniqueKey(Binding.java:45)\n        at org.eclipse.jdt.core.dom.TypeBinding.getKey(TypeBinding.java:455)\n        at\norg.eclipse.jdt.core.dom.DefaultBindingResolver.resolveTypeParameter(DefaultBindingResolver.java:1399)\n        at\norg.eclipse.jdt.core.dom.TypeParameter.resolveBinding(TypeParameter.java:201)\n        at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2525)\n        at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:546)\n        at\norg.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:178)\n        at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2486)\n        at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1162)\n        at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:261)\n        at\norg.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:84)\n        at\norg.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:718)\n        at\norg.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:777)\n        at\norg.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1081)\n        at\norg.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:98)\n        at\norg.eclipse.core.internal.runtime.InternalPlatform.run(InternalPlatform.java:1044)\n        at org.eclipse.core.runtime.Platform.run(Platform.java:783)\n        at\norg.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:82)\n        at\norg.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:147)\n        at\norg.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)\n        at\norg.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:94)\n        at\norg.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:75)\n        at\norg.eclipse.jdt.internal.ui.text.JavaReconciler.process(JavaReconciler.java:339)\n        at\norg.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:204),,,,
100636,, [model] Can't find overriden methods of protected nonstatic inner class.  ,3.1.1,jerome_lanneluc@fr.ibm.com,normal,P3,37058.60347,37135.2745,76.67103009,258,"I'm using 3.1RC2.  There are two symptoms of this bug, written in CAPITAL \nLETTERS in steps 4 & 6 below.\n\nSteps:\n\n1) Open type javax.swing.DefaultCellEditor.\n\n2) Switch to the Java Browsing perspective.\n\n3) In the Members tab, hilite EditorDelegate and press F4 (Open Type \nHierarchy).\n\n4) In the lower pane of the Hierarchy tab, rightclick on setValue(Object) and \npick Declarations>>Hierarchy.  WRONGLY NONE ARE FOUND.\n\n5) In the upper pane of the Hierarchy tab, doubleclick on any one of \nEditorDelegate's subclasses.  The subclass's source is scrolled into view in \nthe source text editor.\n\n6) In the left margin of the source text editor, click on any of the green \ntriangles appearing at any of the subclass's methods.  THE SOURCE TEXT EDITOR \nFAILS TO SCROLL TO THE SUPERTYPE'S DECLARATION OF THAT METHOD.",,,,
100695,, [1.5][search] Renaming a field of generic array type has no effect  ,3.1.1,frederic_fusier@fr.ibm.com,normal,P3,37058.94236,37105.431,46.48863426,528,"3.1RC2\n\neg.\nclass A {\n  Class<Class>[] a;\n  Class<Class>[] b = a;\n  A() {\n    a = null;\n  }\n}\n\nWhile renaming the field ""a"", all ""a""s are unchanged except the declaring one.",,,,
100772,, [1.5][search] Search for declarations in hierarchy reports too many matches  ,3.1.1,frederic_fusier@fr.ibm.com,normal,P3,37061.21597,37117.62991,56.41393519,1161,"RC3\n\npublic class A<T> {\n\tpublic void foo(T t) {\n\t}\n}\n\nclass B extends A<String> {\n\tpublic void foo(String s) {\n\t}\n\tpublic void foo(Integer i) {\n\t}\n}\n\n- search for declaration in hierarchy on foo(Integer i) using the context\n  menu.\n\nobserve that foo(String s) is reported as a match as well.\n\nPlease note that search declaration in hierarchy specifies the two flags \nIJavaSearchConstants.IGNORE_DECLARING_TYPE |\nIJavaSearchConstants.IGNORE_RETURN_TYPE.\n\nHowever, using the search dialog (Ctrl+H) which uses the Java element without\nany flags and search for declarations in workspace reports foo(String s) as well. \n\nIf B doesn't extend A<String> foo(String s) isn't found.",,,,
100808,, [assist] Wrong replace range for package proposals if there is no line termination  ,3.1.1,david_audel@fr.ibm.com,normal,P3,37061.39583,37075.44082,14.04498843,30,"3.1-RC2 test pass\n\nSee bug 100795 for details.\n- have an empty .java file with the contents below (no line termination) \n- invoke code assist at the end of the first line\n\n""package org.""\n\nThe reported completion proposals specify a replace range of [8, 13), while the\ndocument length is only 12. \n\nNote that if there is a trailing space or a newline, the correct replace range\nis reported: [8, 12)\n\nSince jdt-ui does not check the replace ranges, we run into the IAE of\nStyledText eventually (see bug 100795 for the trace).",,,,
100868,, [code assist] Code assist does not recommend methods in anonymous enum subclass  ,3.1.1,tobias_widmer@ch.ibm.com,minor,P3,37061.49306,37117.19653,55.70347222,73,In RC3.  Consider code:\n\npublic enum Foo {\n\tA {\n\t\ttos<<>>\n\t},\n}\n\nWhere the cursor is at <<>>.  Invoking code assist does not offer to override\ntoString: it only offers class names.,,,
101049,103994, Error when parametrized type extending final type as return value.  ,3.1.1,kent_johnson@ca.ibm.com,major,P3,37062.42917,37152.65226,90.22309028,22,"The following code creates an error in eclipse RC3, but compiles using Sun JDK1.5:\n\n1: interface BaseClass<T> {\n2:   <U extends T> U getItem();\n3: }\n\n4: class SubClass implements BaseClass<Boolean> {\n5:   public <U extends Boolean> U getItem() {...}\n6: }\n\nLine 5 gives a warning: \n""The type parameter U should not be bounded by the final type Boolean""\nAs a consequence Eclipse does not think SubClass is implementing BaseClass.\n\nNot that if using ""Add unimplemented methods"" to create the stub in SubClass,\nthis (line #5) is the signature eclipse creates.",,,,
101228,, JME on code assist  ,3.1.1,jerome_lanneluc@fr.ibm.com,normal,P3,37063.29931,37134.36269,71.06337963,96,"RC3\n\n- new workspace, 5.0 is default compliance and 5.0 JRE is default\n- enable 'fill argument names'\n- do code assist and select ArrayList\n- breakpoint in GenericJavaTypeProposal, linme 308: Type parameters are returned\nbut do not exist.\n\npackage test;\n\nimport java.util.ArrayList;\n\npublic class E {\n\n\tObject o= new ArrayL|code assist\n\n}\n\n\n\n!ENTRY org.eclipse.jdt.ui 4 10001 2005-06-22 13:04:21.03\n!MESSAGE Internal Error\n!STACK 1\nJava Model Exception: Java Model Status [<E> [in ArrayList [in ArrayList.class\n[in java.util [in C:\\devel\\jdk1.5.0_03\\jre\\lib\\rt.jar [in Test]]]]] does not exist]\n\tat\norg.eclipse.jdt.internal.core.JavaElement.newNotPresentException(JavaElement.java:468)\n\tat org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:499)\n\tat org.eclipse.jdt.internal.core.JavaElement.getElementInfo(JavaElement.java:232)\n\tat org.eclipse.jdt.internal.core.JavaElement.getElementInfo(JavaElement.java:218)\n\tat org.eclipse.jdt.internal.core.TypeParameter.getBounds(TypeParameter.java:36)\n\tat\norg.eclipse.jdt.internal.ui.text.java.GenericJavaTypeProposal.computeTypeProposal(GenericJavaTypeProposal.java:367)\n\tat\norg.eclipse.jdt.internal.ui.text.java.GenericJavaTypeProposal.computeTypeArgumentProposals(GenericJavaTypeProposal.java:349)\n\tat\norg.eclipse.jdt.internal.ui.text.java.GenericJavaTypeProposal.apply(GenericJavaTypeProposal.java:225)\n\tat\norg.eclipse.jdt.internal.ui.text.java.LazyJavaCompletionProposal.apply(LazyJavaCompletionProposal.java:320)\n\tat\norg.eclipse.jface.text.contentassist.CompletionProposalPopup.insertProposal(CompletionProposalPopup.java:447)\n\tat\norg.eclipse.jface.text.contentassist.CompletionProposalPopup.selectProposalWithMask(CompletionProposalPopup.java:398)\n\tat\norg.eclipse.jface.text.contentassist.CompletionProposalPopup.verifyKey(CompletionProposalPopup.java:777)\n\tat\norg.eclipse.jface.text.contentassist.ContentAssistant$InternalListener.verifyKey(ContentAssistant.java:630)\n\tat\norg.eclipse.jface.text.TextViewer$VerifyKeyListenersManager.verifyKey(TextViewer.java:415)\n\tat\norg.eclipse.swt.custom.StyledTextListener.handleEvent(StyledTextListener.java:55)\n\tat org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:66)\n\tat org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:844)\n\tat org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:868)\n\tat org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:853)\n\tat org.eclipse.swt.widgets.Widget.notifyListeners(Widget.java:661)\n\tat org.eclipse.swt.custom.StyledText.handleKeyDown(StyledText.java:5133)\n\tat org.eclipse.swt.custom.StyledText$7.handleEvent(StyledText.java:4868)\n\tat org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:66)\n\tat org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:844)\n\tat org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:868)\n\tat org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:853)\n\tat org.eclipse.swt.widgets.Widget.sendKeyEvent(Widget.java:881)\n\tat org.eclipse.swt.widgets.Widget.sendKeyEvent(Widget.java:877)\n\tat org.eclipse.swt.widgets.Widget.wmChar(Widget.java:1189)\n\tat org.eclipse.swt.widgets.Control.WM_CHAR(Control.java:3134)\n\tat org.eclipse.swt.widgets.Control.windowProc(Control.java:3037)\n\tat org.eclipse.swt.widgets.Display.windowProc(Display.java:3694)\n\tat org.eclipse.swt.internal.win32.OS.DispatchMessageW(Native Method)\n\tat org.eclipse.swt.internal.win32.OS.DispatchMessage(OS.java:1656)\n\tat org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:2701)\n\tat org.eclipse.ui.internal.Workbench.runEventLoop(Workbench.java:1699)\n\tat org.eclipse.ui.internal.Workbench.runUI(Workbench.java:1663)\n\tat org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:367)\n\tat org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:143)\n\tat org.eclipse.ui.internal.ide.IDEApplication.run(IDEApplication.java:103)\n\tat\norg.eclipse.core.internal.runtime.PlatformActivator$1.run(PlatformActivator.java:226)\n\tat org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:376)\n\tat org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:163)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)\n\tat\nsun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)\n\tat java.lang.reflect.Method.invoke(Method.java:585)\n\tat org.eclipse.core.launcher.Main.invokeFramework(Main.java:334)\n\tat org.eclipse.core.launcher.Main.basicRun(Main.java:278)\n\tat org.eclipse.core.launcher.Main.run(Main.java:973)\n\tat org.eclipse.core.launcher.Main.main(Main.java:948)\n!SUBENTRY 1 org.eclipse.jdt.core 4 969 2005-06-22 13:04:21.03\n!MESSAGE <E> [in ArrayList [in ArrayList.class [in java.util [in\nC:\\devel\\jdk1.5.0_03\\jre\\lib\\rt.jar [in Test]]]]] does not exist",,,,
101380,, [1.5][compiler] Problem when implementing generic interface with method that has enum parameter  ,3.1.1,philippe_mulet@fr.ibm.com,normal,P3,37063.825,37141.28019,77.45518519,84,"Problem with code similar to:\n\npublic class MyClass implements MyInterface{\n\n\tpublic void myMethod(myEnum value) {\n\t\tSystem.out.println(""value is ""+value);\n\t}\n\n\tpublic static void main(String[] args){\n\t\tnew MyClass().myMethod(myEnum.one);\t\t\n\t}\n}\n\ninterface MyInterface<T> {\n\n\tenum myEnum {one,two};\n\t\n\tpublic void myMethod(myEnum value); \n}\n\nSays ""The type MyClass must implement the inherited abstract method\nMyInterface.myMethod (MyInterface.myEnum)""\n\n3.1/RC3",,,,
101425,, Classpath persistence should be resilient with unknown attributes  ,3.1.1,jerome_lanneluc@fr.ibm.com,normal,P3,37064.30833,37138.3197,74.01136574,964,"3.1rc3\n\nFrom release to release, the .classpath file is made richer, and\ninteroperability with previous client (i.e. 3.1 vs 3.0) is restrained due to\npossible use of advanced features.\n\nIn 3.1, the problem worsen due to the conversion of javadoc locations from\nmetadata to classpath attributes. And we had to instruct 3.0 clients to refrain\nfrom committing .classpath file changes to avoid disturbing 3.1 users.\n\nThis could be improved by having the .classpath file generation be resilient\nwith existing attributes, and rather merge its changes into the .classpath file\nrather than rewriting it from scratch and thus erase potential useful information.\n\nMay need to backport this into maintenance updates of previous releases to ease\ninteroperability (3.1.1 and 3.0.?).",,,,
101456,103994, Proposals and Open Declaration fail with NPE  ,3.1.1,kent_johnson@ca.ibm.com,normal,P3,37064.44583,37155.68772,91.24188657,133,"In a certain type of class it's not possible to get proposals and navigate to\ntype (Ctrl + Space & F3 [Standard Shortcuts]), or do refactorings or other\ninteresting stuff. Appended the log and a demo implementation which shows the\nbug. eclipse build is 3.1RC3.\n\n[ Log ]\n\neclipse.buildId=I20050617-1618\njava.version=1.5.0_03\njava.vendor=Sun Microsystems Inc.\nBootLoader constants: OS=win32, ARCH=x86, WS=win32, NL=de_CH\nCommand-line arguments:  -os win32 -ws win32 -arch x86\n\n[...snip...]\n\n!ENTRY org.eclipse.ui.workbench 4 2 2005-06-23 15:18:30.443\n!MESSAGE Problems occurred when invoking code from plug-in:\n""org.eclipse.ui.workbench"".\n!STACK 0\njava.lang.NullPointerException\n\tat\norg.eclipse.jdt.internal.compiler.lookup.ReferenceBinding.implementsInterface(ReferenceBinding.java:681)\n\tat\norg.eclipse.jdt.internal.compiler.lookup.ReferenceBinding.isCompatibleWith(ReferenceBinding.java:766)\n\tat\norg.eclipse.jdt.internal.compiler.lookup.TypeVariableBinding.boundCheck(TypeVariableBinding.java:135)\n\tat\norg.eclipse.jdt.internal.compiler.lookup.ParameterizedTypeBinding.boundCheck(ParameterizedTypeBinding.java:58)\n\tat\norg.eclipse.jdt.internal.compiler.ast.ParameterizedSingleTypeReference.checkBounds(ParameterizedSingleTypeReference.java:40)\n\tat\norg.eclipse.jdt.internal.compiler.lookup.ClassScope.checkParameterizedTypeBounds(ClassScope.java:702)\n\tat\norg.eclipse.jdt.internal.compiler.lookup.ClassScope.connectTypeHierarchy(ClassScope.java:935)\n\tat\norg.eclipse.jdt.internal.compiler.lookup.CompilationUnitScope.connectTypeHierarchy(CompilationUnitScope.java:254)\n\tat\norg.eclipse.jdt.internal.compiler.lookup.LookupEnvironment.completeTypeBindings(LookupEnvironment.java:249)\n\tat\norg.eclipse.jdt.internal.core.hierarchy.HierarchyResolver.accept(HierarchyResolver.java:153)\n\tat\norg.eclipse.jdt.internal.compiler.lookup.LookupEnvironment.askForType(LookupEnvironment.java:131)\n\tat\norg.eclipse.jdt.internal.compiler.lookup.PackageBinding.getTypeOrPackage(PackageBinding.java:178)\n\tat org.eclipse.jdt.internal.compiler.lookup.Scope.getTypeOrPackage(Scope.java:2392)\n\tat org.eclipse.jdt.internal.compiler.lookup.Scope.getType(Scope.java:2137)\n\tat\norg.eclipse.jdt.internal.compiler.ast.SingleTypeReference.getTypeBinding(SingleTypeReference.java:39)\n\tat\norg.eclipse.jdt.internal.compiler.ast.TypeReference.resolveType(TypeReference.java:141)\n\tat\norg.eclipse.jdt.internal.compiler.ast.TypeReference.resolveTypeArgument(TypeReference.java:158)\n\tat\norg.eclipse.jdt.internal.compiler.ast.ParameterizedSingleTypeReference.internalResolveType(ParameterizedSingleTypeReference.java:132)\n\tat\norg.eclipse.jdt.internal.compiler.ast.ParameterizedSingleTypeReference.resolveType(ParameterizedSingleTypeReference.java:217)\n\tat\norg.eclipse.jdt.internal.compiler.ast.TypeReference.resolveSuperType(TypeReference.java:104)\n\tat\norg.eclipse.jdt.internal.compiler.lookup.ClassScope.findSupertype(ClassScope.java:1088)\n\tat\norg.eclipse.jdt.internal.compiler.lookup.ClassScope.connectSuperclass(ClassScope.java:755)\n\tat\norg.eclipse.jdt.internal.compiler.lookup.ClassScope.connectTypeHierarchy(ClassScope.java:927)\n\tat\norg.eclipse.jdt.internal.compiler.lookup.CompilationUnitScope.connectTypeHierarchy(CompilationUnitScope.java:254)\n\tat\norg.eclipse.jdt.internal.compiler.lookup.LookupEnvironment.completeTypeBindings(LookupEnvironment.java:249)\n\tat\norg.eclipse.jdt.internal.core.hierarchy.HierarchyResolver.resolve(HierarchyResolver.java:653)\n\tat\norg.eclipse.jdt.internal.core.hierarchy.HierarchyResolver.resolve(HierarchyResolver.java:486)\n\tat\norg.eclipse.jdt.internal.core.hierarchy.HierarchyBuilder.buildSupertypes(HierarchyBuilder.java:119)\n\tat\norg.eclipse.jdt.internal.core.hierarchy.IndexBasedHierarchyBuilder.build(IndexBasedHierarchyBuilder.java:136)\n\tat\norg.eclipse.jdt.internal.core.hierarchy.TypeHierarchy.compute(TypeHierarchy.java:320)\n\tat\norg.eclipse.jdt.internal.core.hierarchy.TypeHierarchy.refresh(TypeHierarchy.java:1255)\n\tat\norg.eclipse.jdt.internal.core.CreateTypeHierarchyOperation.executeOperation(CreateTypeHierarchyOperation.java:90)\n\tat\norg.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:718)\n\tat\norg.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:777)\n\tat\norg.eclipse.jdt.internal.core.SourceType.newSupertypeHierarchy(SourceType.java:671)\n\tat\norg.eclipse.jdt.internal.core.SourceType.newSupertypeHierarchy(SourceType.java:623)\n\tat\norg.eclipse.jdt.internal.corext.util.SuperTypeHierarchyCache.getTypeHierarchy(SuperTypeHierarchyCache.java:88)\n\tat\norg.eclipse.jdt.internal.corext.util.SuperTypeHierarchyCache.getTypeHierarchy(SuperTypeHierarchyCache.java:78)\n\tat\norg.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:160)\n\tat\norg.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:128)\n\tat\norg.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:251)\n\tat\norg.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:220)\n\tat\norg.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:67)\n\tat\norg.eclipse.core.internal.runtime.InternalPlatform.run(InternalPlatform.java:1044)\n\tat org.eclipse.core.runtime.Platform.run(Platform.java:783)\n\tat\norg.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:289)\n\tat\norg.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:275)\n\tat\norg.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:318)\n\tat org.eclipse.core.internal.jobs.Worker.run(Worker.java:76)\n\n!ENTRY org.eclipse.ui 4 4 2005-06-23 15:18:30.584\n!MESSAGE Exception in Decorator\n\n[...snip...]\n\nDemo Implementaion:\n\npackage bug;\n\nimport java.util.Date;\n\n\npublic abstract class AbstractSnapshot<S extends Snapshot, P extends SnapshotPro\nvider<S>>\n    implements Snapshot<S>\n{\n    private final Date date;\n    private final P provider;\n\n    public AbstractSnapshot(P provider, Date date)\n    {\n        this.provider = provider;\n        this.date = date;\n    }\n\n    public S at(Date d)\n    {\n        return provider.getSnapshot(d);\n    }\n\n    public S shift(int days)\n    {\n        return at(getWhen() /* .shift(days) */);\n    }\n\n    public Date getWhen()\n    {\n        return date;\n    }\n\n    public P getProvider()\n    {\n        return provider;\n    }\n}\npackage bug;\n\nimport java.util.Date;\n\n\nclass ProviderImpl\n    implements SnapshotProvider<SnapshotImpl>\n{\n    public SnapshotImpl getSnapshot(Date arg0)\n    {\n        return null;\n    }\n}\npackage bug;\n\nimport java.util.Date;\n\n\npublic interface Snapshot<S extends Snapshot>\n{\n    Date getWhen();\n\n    public S at(Date when);\n\n    /**\n     * Snapshot, der um <i>days </i> Tage geschoben ist.\n     *\n     * @param days\n     * @return nie <code>null</code>\n     */\n    public S shift(int days);\n}\npackage bug;\n\nimport java.util.Date;\n\n\n// FIXME autocompletion and other navigation methods fail.\n// refactoring (e.g. SnapshotProvider fails also)\nclass SnapshotImpl\n    extends AbstractSnapshot<SnapshotImpl, ProviderImpl>\n{\n\n    public SnapshotImpl(ProviderImpl provider, Date date)\n    {\n        super(provider, date);\n    }\n\n    public void execute()\n    {\n        //\n    }\n}package bug;\n\nimport java.util.Date;\n\n\ninterface SnapshotProvider<S extends Snapshot>\n{\n    S getSnapshot(Date date);\n}",,,,
102284,, [5.0 ] CCE in ParameterizedTypeBinding [code assist]  ,3.1.1,david_audel@fr.ibm.com,normal,P3,37071.23958,37135.35304,64.11346065,102,"3.1\n\nSteps to reproduce:\n- Consider following snippet:\n\npackage p;\n\npublic class Anon {\n\tvoid test() {\n\t\tclass Type<S, T> {\n\t\t\tType<String, String> t= new Type<String, String> \n(<Caret>)\n\t\t}\n\t}\n}\n\n- Invoke content assist\n-> Following exception occurs:\n\njava.lang.ClassCastException: \norg.eclipse.jdt.internal.compiler.lookup.ParameterizedTypeBinding\nat org.eclipse.jdt.internal.codeassist.impl.Engine.getSignature\n(Engine.java:334)\nat org.eclipse.jdt.internal.codeassist.CompletionEngine.findConstructors\n(CompletionEngine.java:2025)\nat org.eclipse.jdt.internal.codeassist.CompletionEngine.complete\n(CompletionEngine.java:1022)\nat org.eclipse.jdt.internal.codeassist.CompletionEngine.complete\n(CompletionEngine.java:1533)\nat org.eclipse.jdt.internal.core.Openable.codeComplete(Openable.java:128)\nat org.eclipse.jdt.internal.core.CompilationUnit.codeComplete\n(CompilationUnit.java:301)\nat org.eclipse.jdt.internal.core.CompilationUnit.codeComplete\n(CompilationUnit.java:294)\nat \norg.eclipse.jdt.internal.ui.text.java.JavaCompletionProcessor.internalComputeCo\nmpletionProposals(JavaCompletionProcessor.java:336)\nat \norg.eclipse.jdt.internal.ui.text.java.JavaCompletionProcessor.computeCompletion\nProposals(JavaCompletionProcessor.java:313)\nat \norg.eclipse.jface.text.contentassist.ContentAssistant.computeCompletionProposal\ns(ContentAssistant.java:1503)\nat \norg.eclipse.jface.text.contentassist.CompletionProposalPopup.computeProposals\n(CompletionProposalPopup.java:261)\nat org.eclipse.jface.text.contentassist.CompletionProposalPopup.access$7\n(CompletionProposalPopup.java:258)\nat org.eclipse.jface.text.contentassist.CompletionProposalPopup$1.run\n(CompletionProposalPopup.java:221)\nat org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:69)\nat org.eclipse.jface.text.contentassist.CompletionProposalPopup.showProposals\n(CompletionProposalPopup.java:216)\nat \norg.eclipse.jface.text.contentassist.ContentAssistant.showPossibleCompletions\n(ContentAssistant.java:1352)\nat \norg.eclipse.jdt.internal.ui.javaeditor.CompilationUnitEditor$AdaptedSourceViewe\nr.doOperation(CompilationUnitEditor.java:188)\nat org.eclipse.ui.texteditor.ContentAssistAction$1.run\n(ContentAssistAction.java:82)\nat org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:69)\nat org.eclipse.ui.texteditor.ContentAssistAction.run\n(ContentAssistAction.java:80)\nat org.eclipse.jface.action.Action.runWithEvent(Action.java:996)\nat org.eclipse.ui.commands.ActionHandler.execute(ActionHandler.java:182)\nat org.eclipse.ui.internal.handlers.LegacyHandlerWrapper.execute\n(LegacyHandlerWrapper.java:108)\nat org.eclipse.core.commands.Command.execute(Command.java:311)\nat org.eclipse.core.commands.ParameterizedCommand.execute\n(ParameterizedCommand.java:396)\nat org.eclipse.ui.internal.keys.WorkbenchKeyboard.executeCommand\n(WorkbenchKeyboard.java:459)\nat org.eclipse.ui.internal.keys.WorkbenchKeyboard.press\n(WorkbenchKeyboard.java:781)\nat org.eclipse.ui.internal.keys.WorkbenchKeyboard.processKeyEvent\n(WorkbenchKeyboard.java:828)\nat org.eclipse.ui.internal.keys.WorkbenchKeyboard.filterKeySequenceBindings\n(WorkbenchKeyboard.java:550)\nat org.eclipse.ui.internal.keys.WorkbenchKeyboard.access$3\n(WorkbenchKeyboard.java:493)\nat org.eclipse.ui.internal.keys.WorkbenchKeyboard$KeyDownFilter.handleEvent\n(WorkbenchKeyboard.java:117)\nat org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:66)\nat org.eclipse.swt.widgets.Display.filterEvent(Display.java:917)\nat org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:842)\nat org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:867)\nat org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:852)\nat org.eclipse.swt.widgets.Widget.sendKeyEvent(Widget.java:880)\nat org.eclipse.swt.widgets.Widget.sendKeyEvent(Widget.java:876)\nat org.eclipse.swt.widgets.Widget.wmChar(Widget.java:1190)\nat org.eclipse.swt.widgets.Control.WM_CHAR(Control.java:3135)\nat org.eclipse.swt.widgets.Control.windowProc(Control.java:3038)\nat org.eclipse.swt.widgets.Display.windowProc(Display.java:3706)\nat org.eclipse.swt.internal.win32.OS.DispatchMessageW(Native Method)\nat org.eclipse.swt.internal.win32.OS.DispatchMessage(OS.java:1656)\nat org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:2711)\nat org.eclipse.ui.internal.Workbench.runEventLoop(Workbench.java:1699)\nat org.eclipse.ui.internal.Workbench.runUI(Workbench.java:1663)\nat org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:367)\nat org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:143)\nat org.eclipse.ui.internal.ide.IDEApplication.run(IDEApplication.java:103)\nat org.eclipse.core.internal.runtime.PlatformActivator$1.run\n(PlatformActivator.java:226)\nat org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:376)\nat org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:163)\nat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\nat sun.reflect.NativeMethodAccessorImpl.invoke\n(NativeMethodAccessorImpl.java:39)\nat sun.reflect.DelegatingMethodAccessorImpl.invoke\n(DelegatingMethodAccessorImpl.java:25)\nat java.lang.reflect.Method.invoke(Method.java:585)\nat org.eclipse.core.launcher.Main.invokeFramework(Main.java:334)\nat org.eclipse.core.launcher.Main.basicRun(Main.java:278)\nat org.eclipse.core.launcher.Main.run(Main.java:973)\nat org.eclipse.core.launcher.Main.main(Main.java:948)",,,,
102492,, [quick fix] Halt in Computing serial version ID...  ,3.1.1,tobias_widmer@ch.ibm.com,normal,P3,37072.47778,37126.34309,53.8653125,60,"Hello,\n\nMy work environments are like the following.\n   Eclipse: 3.1\n   J2SDK: j2sdk1.4.2_08\n   OS: Windows XP Professional\n   Plug-in: MyEclipse, XMLBuddy\n   Framworks in the working project: Hibernate 3.0.5, Struts, ...\n\nAfter newly installing Eclipse 3.1, I imported a project created by earlier \nversions of Eclipse from v2.1. After importing, a list of Problems were \ndetected. Many of them were ""The serializable class XxxxXxxx does not declare \nserialVersionUID..."" in the ""Problems"" view. \n\nFor the problems, I used the Quick Fix (Cntr-1) menu to ""Add generated serial \nversion ID."" By doing this way, I created many sercialVersionUID for classes \nmissing them. But the system got halt when I did the same thing for some \nclasses. Those classes are marked with [*] in the list below, as examples.\n\n[*] public class FileUploader extends HttpServlet {...}\n\n[*] public class SysProfileWrapperImpl implements\n        ProfileWrapper,\n        HttpSessionBindingListener {...}\n\n    public interface ProfileWrapper extends Serializable  {...}\n\n[*] public class TimestampTag extends MyTagSupport {...}\n\n    abstract public class MyTagSupport extends TagSupport {...}\n\n\nThe error message poped up in the [Progress Information] dialog box is \n\n   +---------------------------------------------------------+\n   |     Computing serial version ID...                      |\n   |  ||||||||||||||||||||||||||||||||                       |   \n   |  Starting virtual machine...                            |\n   |                                  [Cancel] [Details >>]  |\n   +---------------------------------------------------------+\n\nAnd it never advanced from a certain point. I clicked the [Cancel] button, and \nthe button became disabled. I waited but nothing happened after that. I \ncouldn't kill the dialog box and so I could get back to the main eclipse \nwindow. The [Detail >>] button initially appeared with disabled status.\n\nI hope you may simulate the situation I had and fix the problem whatever the \nsolution is...\n\nI thank you very much for providing Elipse, very nice development tool for \ndevelopers like me...\n\nSincerely,\n\n\nYunseuk Kim",,,,
102631,, [1.5][compiler] false java error for ambiguous methods  ,3.1.1,kent_johnson@ca.ibm.com,major,P3,37075.21736,37152.62066,77.40329861,297,"The following code does not compile due to two FALSE errors:\n""The method f(boolean, Object[]) is ambiguous for the type BugTest""\n\nWorks with the original Sun javac command line compiler, inside NetBeans and\nIDEA but not with Eclipse (pre 3.1 and released 3.1).\n\npublic class BugTest {\n    void f(boolean b, Object... o) {\n        System.err.println(""f(boolean, Object...) called"");\n    }\n\n    void f(Object... o) {\n        System.err.println(""f(Object...) called"");\n    }\n\n    public static void main(String[] args) {\n        BugTest a = new BugTest();\n        a.f(true);\n        a.f(true, ""foobar"");\n        a.f(""foo"", ""bar"");\n    }\n}",,,,
102645,, [open type] Open Type history shows stale visibility info in type history  ,3.1.1,dirk_baeumer@ch.ibm.com,normal,P3,37075.34792,37140.49708,65.14916667,80,"3.1\n\nSteps to reproduce:\n- Open a public source type using Open Type\n- Change visibility of the type to default\n- Open the type again\n\n-> Type history displays the type as public, the workspace type match is \ncorrectly displayed as default",,,,
103485,103472, [1.5][compiler] compiler: wrongfully accepted method call  ,3.1.1,philippe_mulet@fr.ibm.com,normal,P3,37083.425,37090.40691,6.981909722,134,"3.1\n\n- have the code below\n- javac complains, ecj does not\n- running the code produces a CCE in Integer.compareTo(Integer)\n\n----- snip -----\nclass Hover {\n\t<T extends Comparable<T>> boolean isGreater(T t1, T t2) {\n\t\treturn t1.compareTo(t2) > 0 ? true : false; \n\t}\n\n\tvoid method(Integer i, Double d) {\n\t\tisGreater(i, d);\n\t}\n}\n----------------\n\n----- javac output -----\njavac 1.5.0_03\n/opt/eclipse/workspaces/runtime/workbench/Article/src/com/example/Hover.java:14:\n<T>isGreater(T,T) in com.example.Hover cannot be applied to\n(java.lang.Integer,java.lang.Double)\n\t\tisGreater(i, d);\n                ^\n1 error",,,,
103849,103994, [jdk][compiler] Incorrect ambiguity error for generic types + inheritance  ,3.1.1,kent_johnson@ca.ibm.com,normal,P3,37085.52431,37152.62084,67.09653935,594,"I found a new problem in support for generic types.  See this code:\n\ninterface Jukebox {\n  <M extends Music, A extends Artist<M>> A getArtist (M music);\n}\nclass JukeboxImpl implements Jukebox {\npublic <M extends Music,A extends Artist<M>> A getArtist (M music){return null;}\n  void test () { Elvis king = getArtist(new Rock()); }\n}\ninterface Music {}\nclass Rock implements Music {}\nclass Classic implements Music {}\ninterface Artist<M extends Music> {}\nclass Elvis implements Artist<Rock> {}\nclass Mozart implements Artist<Classic> {}\n\nJDT compiler produces errors like: ""The method getArtist(Rock) is ambiguous\nfor the type JukeboxImpl"".  But JDK 1.5.0_04's javac compiles this code\nnormally; not only the method invocation is okay (no ambiguity), but javac\nmakes the assignments to 'king' and 'amadeus' without even a warning\n(even if I use -Xlint:unchecked or -Xlint:all).\n\nThis behavior of javac doesn't sound very correct either, because the inferred\ntype of getArtist()'s return value should be ""Artist<Rock>"", that is not yet\nassignment-compatible to Elvis, this should produce a compiler error (not just\na type-safety warning, because the incompatibility is in the erased type).\n\nThe bug in JDT is also related to inheritance.  If you remove the interface\nJukebox, this erro disappears.  There is no difference if I use interfaces,\nabstract classes, or a simple base class with a concrete definition of the\nmethod getArtist(); bug always happens if the method overrides something.",,,,
110826,103849, [compiler] Batch compiler doesn't work when set on the bootclasspath  ,3.1.1,Olivier_Thomann@ca.ibm.com,normal,P3,37160.50556,37160.54878,0.043229167,18,"When compiling code that needs to report error messages, the batch compiler\nblows up with this error:\nException in thread ""main"" java.lang.NoClassDefFoundError\n        at\norg.eclipse.jdt.internal.compiler.Compiler.handleInternalException(Compiler.java:399)\n        at org.eclipse.jdt.internal.compiler.Compiler.compile(Compiler.java:348)\n        at\norg.eclipse.jdt.internal.compiler.batch.Main.performCompilation(Main.java:2728)\n        at org.eclipse.jdt.internal.compiler.batch.Main.compile(Main.java:1166)\n        at org.eclipse.jdt.internal.compiler.batch.Main.main(Main.java:1071)\n\nThis comes from the Messages class that doesn't support its field initialization\nwhen loaded from the system class loader (this is the consequence of having the\ncompiler classes on the bootclasspath).\n\nTo reproduce, use the following command line:\njava -Xbootclasspath/a:org.eclipse.jdt.core_3.1.0.jar\norg.eclipse.jdt.internal.compiler.batch.Main  X.java\n\nWhen X is:\npublic class X {\n    ZORK f;\n}",,,,
